---
title: "Package Functions througth 'attributes' (Week 4)"
output:
  html_notebook:
    toc: yes
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    toc: yes
---

In this notebook I'll try to code the functions that will be implemented in the package. Up to here, it has been decided that it would be useful to add some attributes to matrices (which are the basic data structure we are manipulating) somehow simulating the behaviour of classes in R. These attributes will indicate what represent each matrix and in which space (for example, a given matrix $B$ could be the parameter estimation matrix in the coordinates and therefore we need to specify which base is used, i.e. in which particular coordinate space it lies). 

The attributes that has matrices are "space" (ilr or simplex, possibly alr) and "base" (base matrix).

This notebook continues the previous "functions_nb.Rmd" one and inherits its functions, while updating them to the new framework.

### Matrices for the examples

I create a function to recover easily the original 5 matrices that will be used in the examples, as they may be manipulated.

```{r}
example_matrices = function(){
m1 = rbind(c(0.25,0.3,0.2),c(0.5,0.2,0.3),c(0.9,0.05,0.05),c(0.33,0.4,0.24),c(0.2,0.3,0.5),c(0.91,0.05,0.04),c(0.1,0.7,0.2)) 
m2 = rbind(c(0.1,0.4,0.25,0.25),c(0.3,0.3,0.3,0.1),c(0.9,0.05,0.02,0.03),c(0.1,0.7,0.15,0.05),c(0.8,0.1,0.05,0.05),c(0.35,0.25,0.3,0.1),c(0.4,0.1,0.1,0.4)) 
m3 = matrix(c(23,1,32,12,9,11,3)) 
m4 = rbind(c(0.2,0.8),c(0.3,0.7),c(0.9,0.1),c(0.75,0.25),c(0.3,0.7),c(0.15,0.85),c(0.9,0.1))
m5 = rbind(c(3,-4.3),c(0,-2),c(4,5),c(-2,3), c(4,2), c(1,11), c(23,2))
return(list(m1,m2,m3,m4,m5))}
```

```{r}
m1 = example_matrices()[[1]]
m2 = example_matrices()[[2]]
m3 = example_matrices()[[3]]
m4 = example_matrices()[[4]]
m5 = example_matrices()[[5]]
```


# Preliminary Functions

## Closure operator (same as before)

```{r}
closure=function(x, k){ # x the NxD matrix, k the constant (k=1 if missing)
  if (missing(k)){
    newx <- (x)/rowSums(x)
    return(newx)
  }
  else{
    newx <- (k*x)/rowSums(x)
    return(newx)
  }
} 
```

## The perturbation, multiplication and powering  (same as before)

```{r}
pt = function (x,y){
  return(closure(x*y))
}
```



```{r}
pw=function(l,x){ # x the vector (matrix 1xD) and l stands for the scalar
  return(closure(x**l))
}
```




# Transformation functions (ilr, inverseolr,...)

## Function that creates the Helmert Matrix  (same as before)

If $V$ (contrast matrix) is not passed, computations are done with the Helmert Matrix as default.

```{r} 
# Creates de Helmert Matrix given the number of parts of the variable
V_D = function(D){ # D is the dimension (parts)
  V_D = matrix(0L, nrow =D , ncol = D-1)
  for (i in 1:(D-1)){  # pseudodiagonal elements
    V_D[i,i] = (D-i)/(sqrt((D-i+1)*(D-i)))
  }
  for (i in 2:D){ # below pseudodiagonal elements
    for (j in 1:i-1){
      V_D[i,j]=-1/(sqrt((D-j+1)*(D-j)))
    }
  } 
  return(V_D)
}
```


## ILR transformation

Given a matrix NxD and a V contrast matrix, the function returns the ilr-transformed coordinates in a matrix. 

If the matrix has "ilr" attribute, it returns an error: "already in coordinates space".
If the matrix has "simplex" attribute or has no attribute, it is given two attributes: "ilr" (that substitutes "simplex", if it is the case) and the V base matrix used.


I.e: 

Simplex -> Ilr
NoSpecified -> Ilr
Ilr -> Raise Error


```{r}
ilr = function(x, V){ # x matrix N x D
  if (is.null(attr(x, "space"))){attr(x, "space") <- "simplex"}
  if (attr(x, "space")=="coord"){stop("The matrix is already in the coordinates space.")}
  if (missing(V)){V=V_D(dim(x)[2])}
  x = closure(x)
  ilr_mat = t(t(V)%*%t(log(x)))
  attr(ilr_mat, "space") <- "coord"
  attr(ilr_mat, "contrast") <- V
  return(ilr_mat)
}
```

Examples:

```{r}
ilr(m1)
```

However, if it is tried to pass a ilr-matrix as an input (is this correct in English?):

```{r}
attr(m1, "space") = "coord"

ilr(m1)
```



## Inverse of the Ilr

This is the contrary case. If given a matrix with a "simplex" attribute, it would raise an error. If $V$ base is specified, that matrix is used. If not, it is preferred the base matrix that is given as an attribute of the matrix to transform. If none of them exist, the Helbert matrix is used.

I.e:

Ilr -> Simplex
NoSpecified -> Simplex
Simplex -> Raise Error

V is used with this preference:

1) V specified as argument
2) Contrast matrix attribute of the data
3) Helmert Matrices

This scheme is used hereinafter


```{r}
inverseilr=function(x,V){
  if (is.null(attr(x, "space"))){attr(x, "space") <- "coord"}
  if (attr(x, "space")=="simplex"){stop("The matrix is already in the simplex space.")}
  x = t(x)
  if (missing(V)){
    if (is.null(attr(x,"contrast"))){
      V=V_D(dim(x)[1]+1)
    }
    else{V = attr(x,"contrast")}
  }
  inv_mat = closure(t(exp(V%*%x)))
  attr(inv_mat,"space") = "simplex"
  attr(inv_mat,"contrast") = NULL
  return(inv_mat)
}
```

An example:

```{r}
ilrm2 = ilr(m2) 
ilrm2
```

```{r}
inverseilr(ilrm2)
```

However, if we try to input a matrix in the simplex space...

```{r}
m1 = example_matrices()[[1]]
m1
```

```{r}
ilr(m1)
```


```{r}
Vex = compositions::ilrBase(D=3)
Vex   
```

```{r}
inverseilr(ilr(m1),V=Vex)
```


# Functions for the Regression 

## Estimation of the coefficients (Same than before)

Given the model: $\begin{pmatrix} y_1\\ y_2\\ ...\\ y_{p}\end{pmatrix} = D\begin{pmatrix}\beta_1\\\beta_2\\...\\ \beta_{p}\end{pmatrix} + \begin{pmatrix}u_1\\u_2\\...\\ u_{p} \end{pmatrix}$

The BLUE estimator of $B$ is obtained computing: 

$\hat{B} = (X^TX)^{-1}X^TY$

```{r}
mlm = function(Y,X){ # only the dependent and independent matrices are needed
  ## use solve(t(X),Y) or QR algorithm qr.solve(), cholesky (I HAVE USED QR)
  B = solve(crossprod(X),crossprod(X,Y),tol=1e-21)
  return(B)
}
```

## Estimation of the variance (Same than before)

### Function 20. Variance-covariance matrices.

In order to obtain the estimator of the variance matrix of the parameters, first it is needed to estimate the common covariance structure $\Sigma$. Recall that $\mathrm{cov}(Y)=I_n\otimes \Sigma$. Then: 

$\hat{\Sigma}=\dfrac{Y'(I-X(X'X)^{-1}X')Y}{n}=\dfrac{(Y-X\hat{B})'(Y-X\hat{B})}{n}$

```{r}
est_var = function(X,Y,B){ # page 146 kevin
  if (missing(B)){B=mlm(Y,X)}
  n=dim(Y)[1]
  sig = (1/n)*t(Y-X%*%B)%*%(Y-X%*%B)
  return(sig)
}
```

Now we can use the $\mathrm{cov}(\hat{\beta})$ estimator from the Kevin book:

```{r}
# p 145 Kevin (5.13)

b_cov = function(X,Y,B){
  sig = est_var(X,Y,B)
  cov = kronecker(sig,solve(t(X)%*%X))
  return(round(cov,5))
}

```

## Compositional Regressions 

### xy reg (coefficients est.)

Recall that the regression in the ILR coordinate space is defined by:

$\mathrm{ilr}(\mathbf{Y}_i) = \mathbf{b}_0^*+ \sum_{q=1}^Q\mathrm{ilr}(\mathbf{X}_{qi})\mathbf{B}^*_q + \sum_{k=1}^K Z_{ki} \mathbf{b}^*_k + \mathrm{ilr}(\epsilon_i)$.

This function:
  - Can take Y in the ilr (then no first transformation is carried out, if it features the attribute "space"="ilr") or the simplex space (by default, if no attribute indicated).
  - Can take any X in the ilr (then no first transformation is carried out) or the simplex space (by default, if no attribute indicated).
  - To be precise: it cannot take some X variables in the ilr space and some in the simplex. 
  - Take Z in the ilr space.
  - Return (optional) a named list, such that the user can easily write, for example: results\$bstar and recover specifically the ilr matrix of coefficients $B^*$.
  - Print (optional) the results.
  
  - As previously, if a list of base matrices V is indicated, it is used (if Y,X in the simplex, raise an error if not -- this could be done, but it is a headache and I believe the use is limited). If not, those indicated as an attribute are used (if Y,X are ilr matrices).

Therefore, this first function takes every variable that is needed to carry out the regression and returns those variables in the ilr space with the base matrices already as attributes.


```{r}
var2ilr = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE){ 
  
  # determine if variables are in the simplex or in ILR coordinates
  n_simplex = 0
  n_ilr     = 0
  
  if (is.null(attr(Y,"space"))){
    n_simplex = 1
  }
  
  if (!is.null(attr(Y,"space"))){
    if (attr(Y,"space")=="simplex"){
      n_simplex=1
    }
    else{
      n_ilr=1
    }
  }
  
  for (k in 1:length(X)){
    if (is.null(attr(X[[k]],"space"))){
    n_simplex = n_simplex+1}
    if (!is.null(attr(X[[k]],"space"))){
      if (attr(X[[k]],"space")=="simplex"){
        n_simplex=n_simplex+1
        }
      else{
        n_ilr=n_ilr+1
      }
    }
  }
  
  # case when X, Y is in the simplex
  
  # if V specified
  
  if (!is.na(V[[1]][1,1])){
    if (length(V)!=(1+length(X))){stop("When using the optional argument 'V' it is needed to specify one base matrix for the independent variable and one for each of the q dependent variable in a list that takes the form V = list(V_Y,V_X1...,V_Xq).")}
    }
    
  # if V not specified
  
  if (n_ilr==0){
    if (is.na(V[[1]][1,1])){
      V=list(V_D(dim(Y)[2])) # this the 'standard' contrast matrix for Y
      for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
        V=c(V,list(V_D(dim(X[[i]])[2])))
      }
    }
    
  # now we have V for the simplex variables case
  
  # transform Y into ilr coordinates

  ty = ilr(Y, V[[1]])
    
  # transfrom X to the ilr coordinates
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  }
  
  
  # case where some variables in the simplex, some in ilr
  
  if (min(c(n_simplex,n_ilr))!=0){
    stop("Every variable should be in the same space, whether ilr coordinates or the simplex.")
  }
    
  # every variable in ilr coordinates: V should be specified in the arguments or in the attributes of the data Y,X
  
  if (!is.na(V[[1]][1,1])){
    if (!is.null(attr(Y,"contrast"))){
      equal = TRUE
      for (k in 1:(length(X)+1)){
        if (k==1){
          vk = V[[1]]
          va = attr(Y,"contrast")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
        else{
          vk = V[[k]]
          va = attr(X[[k-1]],"contrast")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
      }
      if (!equal){warning("At least one contrast matrix given in V does not coincide with its analogous in the attributes of the data.\n")}
    }
  }
  
  if (n_simplex==0){
    # construct ty (and recover V if not specified)
    if (is.na(V[[1]][1,1])){
      if (is.null(attr(Y,"contrast"))){
        stop("When using data in the coordinates space, their associated contrast matrices are needed. They can be attached as an attribute of each matrix of data or directly given as an input in V.")}
      else{
        V[[1]]=attr(Y,"contrast")
        for (k in 1:length(X)){V[[k+1]]=attr(X[[k]],"contrast")
        }
      }
    }
    ty = Y
    # construct tx (and recover V)
    tx = matrix(numeric(dim(X[[1]])[1]))+1
    for (k in 1:length(X)){
      tx = cbind(tx,X[[k]])
      }
    if(constant==FALSE){ # should remove the vector of zeros if no constant is required
      tx=tx[,-1]
      }
    if (!is.na(Z[[1]][1,1])){
      for (z in Z){
        tx=cbind(tx,z)
      }
    }
  }
  
  return (list(Y=ty,X=tx,V=V,constant=constant))
}
```

Some examples (I should recover the original matrices)

```{r}
m1 = example_matrices()[[1]]
m2 = example_matrices()[[2]]
m3 = example_matrices()[[3]]
m4 = example_matrices()[[4]]
m5 = example_matrices()[[5]]
```



```{r}
Vtest = var2ilr(m1,list(m2))$V
```

```{r}
Vtest[[1]][1,2]=Vtest[[1]][1,1]
Vtest[[1]][1,1]=0
```

This is an example of the warning:

```{r}
var2ilr(ilr(m1),list(ilr(m2)), V= Vtest)
```

xy_reg is the same function than before but there are two modes:

- (report/presentation mode): pres=TRUE
- (return mode): by default, pres=FALSE (return a named list such that xy_reg(...)$B_ilr returns the B matrix in the coordinates space and so)

- intermediate prints can be enabled with verbose=TRUE

```{r}
# eq 4 ASJ paper (Ngyugen, Laurent, Thomas-Agnan, Ruiz-Gazen)

# VERSION 2.0.0 (with attributes and using the var2ilr function)

xy_reg = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  input = var2ilr(Y,X,Z,V,constant)
  ty = input$Y
  tx = input$X
  constant = input$constant
  V = input$V
  
  if (dim(ty)[1]<=dim(tx)[2]){
    warning("WARNING: Number of ilr parameters to be estimated greater than sample size \n")
    if (verbose){print(" ")}
  }
  
  if (verbose){
  print("XY REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inverseilr(t(Bstar[1,]),V[[1]])
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = V[[1]]%*%t(matrix_x)%*%t(V[[i+1]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz-1
      c_k = inverseilr(matrix_z, V[[1]])
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "coord"
  attr(tx,"contrast") = V[-1]
  
  attr(Bs,"space")="simplex"
  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  
  if (!pres){return(list(Y_coord = ty, X_coord = tx, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues))} # return results if not pres
  
  
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    
    # sds
    dimilr = dim(Y)[2]-1
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
    print("--------------------------------------------")
    print(paste("SSR: ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```

```{r}
m1 = example_matrices()[[1]]
m2 = example_matrices()[[2]]
m3 = example_matrices()[[3]]
m4 = example_matrices()[[4]]
m5 = example_matrices()[[5]]
```

```{r}
xy_reg(Y=m1,X=list(m2),Z=list(m5),constant=TRUE,verbose=FALSE)
```


```{r}
results$Y_coord
```

Example with pres=TRUE: 

```{r}
xy_reg(Y=m1,X=list(m2),Z=list(m5),constant=TRUE,verbose=FALSE, pres=TRUE)
```

## Output from MVLM package

I believe I have replicated it in a correct way, as we are only interested in coefficients and sds.

```{r}
install.packages("MVLM")
library("MVLM")
```

I am not sure that 'y.rsq' retuns the sds. This is what the documentation state about it: "A matrix containing in its first row the overall variance explained by the model
for variable comprising Y (columns). The remaining rows list the variance of
each outcome that is explained by the conditional effect of each predictor"

```{r}
# example from the documentation: 

data(mvlmdata)
Y <- as.matrix(Y.mvlm)
# Main effects model
mvlm.res <- mvlm(Y ~ Cont + Cat + Ord, data = X.mvlm)
print("are this sds?")
print(mvlm.res$y.rsq)

print("coefficients")
print(mvlm.res$beta.hat)
```

I do not see this interesting to us: 

```{r}
summary(mvlm.res)
```

```{r}
summary(lm(m1[,1]~m2))
```



# Impact Functions

I will start coding the function impacts(Y,X) which would compute the impacts directly from data. Features:

- Personalised V bases

Later I will add the following features:

- specifying B (coefficients matrix)
- adding total option

It will return a matrix with the computed impacts and then we can start thinking in constructing a report.

Just to be clear, this is the explanation: (if it is, I will translate it properly here)

![Explanation of Impacts](/Users/ivanrendobarreiro/coda/img/explanation_impact.jpg)
Therefore, first, I need a function to compute $\mathbb{E}^\oplus Y = \left(b_0\right) \oplus \left(B_1\boxdot X_1 \oplus ...\oplus B_Q \boxdot X_Q\right) \oplus \left(b_1\odot Z_1 \oplus ... \oplus b_K\odot Z_K\right)$

(I believe I can skip this -I have problems with the matrix multiplication- and comupte E(Y) in the ilr space and transform it to the simplex.)


```{r} 
xy_impact_data = function(Y,X,Z=list(matrix()),V=list(matrix()), constant=TRUE){
  res = xy_reg(Y,X,Z,V,constant)
  B = res$B_coord
  tx = res$X_coord
  Bsimplex = res$B_simplex
  exp_Yilr = tx%*%B # fitted values
  Vy = attr(B,"contrast")[[1]]
  exp_Y_simplex = inverseilr(exp_Yilr,Vy)
  I_D = diag(dim(exp_Y_simplex)[2])
  N=dim(exp_Y_simplex)[1]
  impacts = list()
  for (i in (1:N)){
    W_i = I_D - matrix(1,dim(exp_Y_simplex)[2],1)%*%exp_Y_simplex[i,]
    imp_i = W_i%*%t(Bsimplex)
    impacts[[i]] = t(imp_i)
  }
  return(impacts)
}
```

It returns one matrix for each observation:

```{r}
m1 = example_matrices()[[1]]
m2 = example_matrices()[[2]]
m3 = example_matrices()[[3]]
m4 = example_matrices()[[4]]
m5 = example_matrices()[[5]]
```

```{r}
m2
```


```{r}
xy_impact_data(Y=m1,X=list(m2))
```

Here impacts for a specific B (mat of coef.). First, I need a function to transform B into B* and another from B to B*

```{r}
bstar2b = function(Bstar,Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE){ # Bstar is the sp. B*, Y,X,Z in the simplex
  input = var2ilr(Y,X,Z,V,constant)
  ty = input$Y
  tx = input$X
  constant = input$constant
  V = input$V
  
  # take the base matrix in B if it exists
  
  if (!is.null(attr(Bstar,"contrast"))){
    V = attr(Bstar,"contrast")
  }
  
  Bs = t(matrix(numeric(dim(Y)[2])))
  if (constant==TRUE){
    b0=inverseilr(t(Bstar[1,]),V[[1]])
    Bs = rbind(Bs, b0)
  }
  h=2
  for (i in 1:length(X)){
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = V[[1]]%*%t(matrix_x)%*%t(V[[i+1]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
  }
  
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz-1
      c_k = inverseilr(matrix_z, V[[1]])
      Bs = rbind(Bs, c_k)
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "coord"
  attr(tx,"contrast") = V[-1]
  
  attr(Bs,"space")="simplex"
  return(Bs)
  
}
```

We can test that the function works fine:

```{r}
Btest = xy_reg(Y=m1,X=list(m2))$B_coord
bstar2b(Btest,m1,list(m2))
```

```{r}
xy_reg(Y=m1,X=list(m2))$B_simplex
```


I am using the following equations to change the space of B and B*:

$B = V_LB^*V'_D$
$B^* = V'_LBV_D$


```{r}
xy_impact_coef = function(Y,X,Z=list(matrix()),V=list(matrix()), constant=TRUE, B, Bspace="coord"){ #Bspace could be 'coord' or 'simplex' and specifies which kind of matrix of coefficients is given.
  
  # if Bspace = simplex: transform to B*, get EY*, transform to EY and get the impacts with EY and B in the simplex
  
  if (Bspace =="simplex"){
    Bs = matrix(0,1,dim(Y)[2]-1)
    res = xy_reg(Y,X,Z,V,constant)
    tx = res$X_coord
    if (is.na(V[[1]][1,1])){
      V = attr(res$B_coord, "contrast")
      print(V)
    }
    
    h=1
    if (constant){
      b0s = ilr(t(matrix(B[1,])))
      h=h+1
      Bs = rbind(Bs, b0s)
    }
    
    for (i in 1:length(X)){
      dimx = dim(X[[i]])[2]
      Bq = B[h:(h+dimx-1),]
      Bqs = t(V[[1]])%*%t(Bq)%*%V[[i+1]]
      h=h+dimx
      Bs = rbind(Bs, t(Bqs))
    }
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        dimz = dim(Z[[i]])[2]
        bz = B[h:(h+dimz-1),]
        bzs = ilr(bz,V[[1]])
        h=h+dimz
        Bs = rbind(Bs, bzs)
      }
    }
    Bs = Bs[-1,] # this is the B* matrix (until here it works well - checked)
    exp_Yilr = tx%*%Bs
    exp_Y_simplex = inverseilr(exp_Yilr,V[[1]])
    I_D = diag(dim(exp_Y_simplex)[2])
    N=dim(exp_Y_simplex)[1]
    Bsimplex = B
    impacts = list()
    for (i in (1:N)){
      W_i = I_D - matrix(1,dim(exp_Y_simplex)[2],1)%*%exp_Y_simplex[i,]
      imp_i = W_i%*%t(Bsimplex)
      impacts[[i]] = t(imp_i)
      }
    return(impacts)
  }
  
  
  # if Bspace = ilr: i) compute EY*, transform to EY, get B* -> B and get the impacts with EY and B in the simplex
  
  if (Bspace=="coord"){
    res = xy_reg(Y,X,Z,V,constant)
    tx = res$X_coord
    if (!is.null(attr(B,"contrast"))){
      V=attr(B,"contrast")
    }
    if (is.null(attr(B,"contrast"))){
      if (is.na(V[[1]][1,1])){
        stop("A base V should be provided when the input is the matrix of coefficients in the ILR space.")
      }
    }
    exp_Yilr = tx%*%B
    Vy = attr(B,"contrast")[[1]]
    exp_Y_simplex = inverseilr(exp_Yilr,Vy)
    I_D = diag(dim(exp_Y_simplex)[2])
    N=dim(exp_Y_simplex)[1]
    Bsimplex = bstar2b(B,Y,X,Z,V,constant)
    impacts = list()
    for (i in (1:N)){
      W_i = I_D - matrix(1,dim(exp_Y_simplex)[2],1)%*%exp_Y_simplex[i,]
      imp_i = W_i%*%t(Bsimplex)
      impacts[[i]] = t(imp_i)
      }
    return(impacts)
  }
}
```

In this example, performing 'xy_impact_coef' from B_ilr or B_simplex or 'xy_impact_data' should return the same results, as the matrices of coeff in the ilr and simplex space are the same that it is computed internally in 'xy_impact_data'.

```{r}
m1 = example_matrices()[[1]]
m2 = example_matrices()[[2]]
m3 = example_matrices()[[3]]
m4 = example_matrices()[[4]]
m5 = example_matrices()[[5]]
```

```{r}
# matrices for the example

Btestsimplex = xy_reg(Y=m1, X=list(m2), Z=list(m5))$B_simplex
Btestilr     = xy_reg(Y=m1, X=list(m2), Z=list(m5))$B_coord
```


```{r}
# impacts having a specific B (in the simplex)

xy_impact_coef(Y=m1,X=list(m2), Z=list(m5), B=Btestsimplex, Bspace="simplex")
```


```{r}
# impacts having a specific B* (in the ilr)
xy_impact_coef(Y=m1,X=list(m2), Z=list(m5), B=Btestilr, Bspace="coord")
```

```{r}
# impacts directly from data
xy_impact_data(Y=m1,X=list(m2), Z=list(m5))
```

```{r}
xy_reg(m1,list(m2))
```


#### xy-Impact function from results of the regression

```{r}
xy_impacts = function(results){ # the unique argument is the anmes list that comes from the xy_reg function
    tx = results$X_coord
    B = results$B_coord
    exp_Yilr = tx%*%B
    Vy = attr(B,"contrast")[[1]]
    exp_Y_simplex = inverseilr(exp_Yilr,Vy)
    I_D = diag(dim(exp_Y_simplex)[2])
    N=dim(exp_Y_simplex)[1]
    Bsimplex = results$B_simplex
    impacts = list()
    for (i in (1:N)){
      W_i = I_D - matrix(1,dim(exp_Y_simplex)[2],1)%*%exp_Y_simplex[i,]
      imp_i = W_i%*%t(Bsimplex)
      impacts[[i]] = t(imp_i)
      }
    return(impacts)
}
```

It works:

```{r}
xy_impacts(xy_reg(m1,list(m2)))
```

## X-Regression and X-impacts

### x_reg

```{r}
x_reg = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  ty = Y #already in coordinates
  if (is.na(V[[1]][1,1])){
    for (i in 1:length(X)){
      V[[i]] = V_D(dim(X[[i]])[2])
    }
  }
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  
  if (dim(ty)[1]<=dim(tx)[2]){
    warning("WARNING: Number of ilr parameters to be estimated greater than sample size \n")
    if (verbose){print(" ")}
  }
  
  if (verbose){
  print("XY REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=Bstar[1,]
    Bs=rbind(Bs, Bstar[1,])
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = t(matrix_x)%*%t(V[[i]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz-1
      c_k = matrix_z
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "coord"
  attr(tx,"contrast") = V
  
  attr(Bs,"space")="simplex"
  
  if (!pres){return(list(Y_coord = ty, constant = constant, X_coord = tx, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov))} # return results if not pres
  
  
  # till here
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    
    # sds
    dimilr = dim(Y)[2]
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
  }
}
```


```{r}
x_reg(m1,list(m2),list(m5))
```


### x_impacts

Apparently, it works

```{r}
x_impacts = function(results){ # the unique argument is the anmes list that comes from the xy_reg function
    B = results$B_coord
    constant = results$constant
    Vx = attr(B,"contrast")
    if (constant){
      if (dim(B)[2]==1){B=matrix(B[-1,])}
      else{
        B = B[-1,]
      }
    }
    h=1
    impacts=list()
    for (i in 1:length(Vx)){
      dimx = dim(Vx[[i]])[1]
      if (is.null(dim(B))){B=t(matrix(B))}
      bstar = B[h:(h+dimx-2),]
      h=h+dimx-1
      impacts[[i]]=Vx[[i]]%*%bstar
      }
    return(impacts)
}
```

It works. Each matrix of the list is: $\dfrac{\partial \mathbb E \check Y}{\partial\log\check X_i}=V^{X_i}b^*_i$ for $i$ the i-th explanatory compositional variable.



```{r}
x_impacts(x_reg(m1,list(m2)))
```


```{r}
x_impacts(x_reg(m1,list(m2,m4)))
```

```{r}
x_impacts(x_reg(m3,list(m2,m4)))
```

## Y-impact functions

```{r}
y_reg = function(Y,X,V=NaN,constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # X = tx as it is already in coord.
  for (i in 1:length(X)){
    tx = cbind(tx,X[[i]])
    }
  if (constant==FALSE){ # should remove the vector of ones if no constant is required
    tx=tx[,-1]
  }
  
  # transform Y to coordinates
  if (!is.na(V)){ # if V specified as argument
    ty = ilr(Y,V)
  }
  
  else{
    V=V_D(dim(Y)[2]) # if V not specified as argument
    ty=ilr(Y,V)}
  
  if (verbose){
  print("XY REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}
  
  Bstar = mlm(ty,tx)
  # bcov = b_cov(tx,ty,Bstar) ######## some problems here
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inverseilr(t(Bstar[1,]),V)
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  if (!is.na(X[[1]][1,1])){
    for (i in 1:length(X)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, X", i, sep=""))}
      dimx = dim(X[[i]])[2]
      if (h==(h+dimx-1)){matrix_x = t(matrix(Bstar[h,]))}
      if (h!=(h+dimx-1)){matrix_x = Bstar[h:(h+dimx-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimx-1
      c_k = inverseilr(matrix_x, V)
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "coord"
  attr(tx,"contrast") = NaN
  
  attr(Bs,"space")="simplex"
  
  if (!pres){return(list(Y_coord = ty, X_coord = tx, B_coord = Bstar, B_simplex = Bs))} 
# return results if not pres + Bcoord_cov=bcov
  
  
  
  # part of PRES = TRUE
  
  if (pres=="IN_PROGRESS"){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    
    # sds
    dimilr = dim(Y)[2]-1
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
  }
}
```

```{r}
m1
```

```{r}
m2
```

```{r}
y_impacts = function(results){ #results argument regers to the output of y_reg
  # first we need EY*
  Bcoord = results$B_coord
  Vy = attr(results$Y_coord, "contrast")
  xcoord = results$X_coord
  EYcoord = xcoord%*%Bcoord
  EYsimpl = inverseilr(EYcoord,Vy)
  D = dim(Vy)[1]
  impacts=list()
  for (i in 1:(dim(EYsimpl)[1])){
    Wi = diag(D) - matrix(1,D,1)%*%t(EYsimpl[i,])
    Wistar = Wi%*%Vy
    impacts[[i]] = t(Wistar%*%t(Bcoord))
  }
  return(impacts)
}
```


```{r}
y_impacts(y_reg(m1,list(m2)))
```

I will try this functions in a large dataset, if they work, I'll compute some tiny example by hand. The large dataset is the 'BDDSegX_ext.RData' dataset.

(The regressions performed do not follow any criterion)

```{r}
load(file = "/Users/ivanrendobarreiro/Documents/m1_econometrics/internship/week1/data_db/BDDSegX_ext.RData")
```

```{r}
BDDSegX
```

SimS_A, SimS_B, SimS_C, SimS_D, SimS_E form the unique compositional variable: not possible to test xy-model but xy-model features the most developed code of the three models, so I simulate it.

I'll simulate a 3 part variable.

```{r}
N = 152
x1 = rnorm(N, mean=100, sd=10)
x2 = rnorm(N, mean=90, sd=15)
new = cbind(matrix(x1),x2)
new = closure(new) # these are a D=2 new variable
```

other variables:

TTC_SP98 
Immat_neuf_VP

```{r}
m1 = matrix(BDDSegX$Immat_neuf_VP)
m2 = matrix(BDDSegX$TTC_SP98)
mc = BDDSegX[,c("SimS_A","SimS_B","SimS_C","SimS_D","SimS_E")]
```

```{r}
dim(new)
```


### x model

```{r}
resx = x_reg(Y = m1, X = list(mc,new), Z=list(m2))
x_impacts(resx) 
```

### y model

```{r}
resy = y_reg(Y = mc, X = list(m1,m2))
y_impacts(resy)[1:3] # there are a lot of impacts
```

### xy model

```{r}
resxy = xy_reg(Y = mc, X = list(new), Z=list(m1,m2))
y_impacts(resxy)[1:3] # there are a lot of impacts
```

Ill plot it, I would like to see them.

```{r}
imp_test = y_impacts(resxy)
ts1=numeric(length(imp_test))
ts2=numeric(length(imp_test))
for (i in 1:length(imp_test)){
  ts1[i]=imp_test[[i]][1,1] # the first element of the first column, for example
  ts2[i]=imp_test[[i]][4,5] # and the 4,5 
}
```

```{r}
plot(ts1,type="l",col="blue",ylim=c(-2,-1.65))
lines(ts2, col="red")
```

They are such as I would expect. :)

## Results to test functions by hand

### example matrices

```{r}
cvar1 = rbind(c(0.25,0.3,0.2),c(0.5,0.2,0.3),c(0.9,0.05,0.05),c(0.33,0.4,0.24))
cvar2 = rbind(c(0.6,0.4),c(0.3,0.7),c(0.9,0.1),c(0.3,0.7))
ncvar = matrix(c(4,1,10,3)) 
```

Compositional variable of D=3, N=4
```{r}
cvar1
```

Compositional variable of D=2, N=4
```{r}
cvar2
```

Standard variable, N=4

```{r}
ncvar
```


### xy-model

$cv_1 = \beta_0 + \beta_1cv_2 + \beta_2ncv$

#### xy-reg

```{r}
V_D(2)
```


```{r}
xy_reg(cvar1,list(cvar2),list(ncvar))
```

#### xy-impacts


```{r}
xy_impacts(xy_reg(cvar1,list(cvar2),list(ncvar)))
```

my inverse...

```{r}
xtx = rbind(c(4,0.6414,18),c(0.6414,3.2148,14.286),c(18,14.286,126))
(1/40.3386)*(xtx%*%xtx - 133.218*xtx + 393.423*diag(3))
```

concides!

```{r}
solve(xtx)
```


### Generator of bases through GS:

```{r}
qr(m4)$rank ### THIS IS THE KEY!!!!!
```



