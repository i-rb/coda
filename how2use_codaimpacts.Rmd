---
title: "create_package"
output:
  html_notebook:
    toc: yes
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    toc: yes
---

This brief notebook is only to create the package

```{r}
example_matrices = function(){
m1 = rbind(c(0.25,0.3,0.2),c(0.5,0.2,0.3),c(0.9,0.05,0.05),c(0.33,0.4,0.24),c(0.2,0.3,0.5),c(0.91,0.05,0.04),c(0.1,0.7,0.2)) 
m2 = rbind(c(0.1,0.4,0.25,0.25),c(0.3,0.3,0.3,0.1),c(0.9,0.05,0.02,0.03),c(0.1,0.7,0.15,0.05),c(0.8,0.1,0.05,0.05),c(0.35,0.25,0.3,0.1),c(0.4,0.1,0.1,0.4)) 
m3 = matrix(c(23,1,32,12,9,11,3)) 
m4 = rbind(c(0.2,0.8),c(0.3,0.7),c(0.9,0.1),c(0.75,0.25),c(0.3,0.7),c(0.15,0.85),c(0.9,0.1))
m5 = rbind(c(3,-4.3),c(0,-2),c(4,5),c(-2,3), c(4,2), c(1,11), c(23,2))
return(list(m1,m2,m3,m4,m5))}
```

```{r}
m1 = example_matrices()[[1]]
m2 = example_matrices()[[2]]
m3 = example_matrices()[[3]]
m4 = example_matrices()[[4]]
m5 = example_matrices()[[5]]
```

```{r}
# this is to delete the past elements in the enviroment
rm(list = ls())
```

# All Defined Functions 

## Closure

```{r}
closure=function(x, k){ # x the NxD matrix, k the constant (k=1 if missing)
  if (missing(k)){
    newx <- (x)/rowSums(x)
    return(newx)
  }
  else{
    newx <- (k*x)/rowSums(x)
    return(newx)
  }
} 
```

## Helmert Matrix for D parts

```{r} 
# Creates de Helmert Matrix given the number of parts of the variable
V_D = function(D){ # D is the dimension (parts)
  V_D = matrix(0L, nrow =D , ncol = D-1)
  for (i in 1:(D-1)){  # pseudodiagonal elements
    V_D[i,i] = (D-i)/(sqrt((D-i+1)*(D-i)))
  }
  for (i in 2:D){ # below pseudodiagonal elements
    for (j in 1:i-1){
      V_D[i,j]=-1/(sqrt((D-j+1)*(D-j)))
    }
  } 
  return(V_D)
}
```

## ILR Transformation

```{r}
ilr = function(x, V){ # x matrix N x D
  if (is.null(attr(x, "space"))){attr(x, "space") <- "simplex"}
  if (attr(x, "space")=="ilr_coord"){stop("The matrix is already in the ILR coordinates space.")}
  if (attr(x, "space")=="alr_coord"){stop("The matrix is in the ALR coordinates space. Matrix should be in the simplex space.")}
  if (missing(V)){V=V_D(dim(x)[2])}
  x = closure(x)
  ilr_mat = t(t(V)%*%t(log(x)))
  attr(ilr_mat, "space") <- "ilr_coord"
  attr(ilr_mat, "contrast") <- V
  return(ilr_mat)
}
```

## Inverse of the ILR

```{r}
inverseilr=function(x,V){
  if (is.null(attr(x, "space"))){attr(x, "space") <- "ilr_coord"}
  if (attr(x, "space")=="simplex"){stop("The matrix is already in the simplex space.")}
  x = t(x)
  if (missing(V)){
    if (is.null(attr(x,"contrast"))){
      V=V_D(dim(x)[1]+1)
    }
    else{V = attr(x,"contrast")}
  }
  inv_mat = closure(t(exp(V%*%x)))
  attr(inv_mat,"space") = "simplex"
  attr(inv_mat,"contrast") = NULL
  return(inv_mat)
}
```

## ALR

```{r}
alr = function(x,R=dim(x)[2]){ # x: N x D matrix, R : Reference (last term by default)
  if (is.null(attr(x, "space"))){attr(x, "space") <- "simplex"}
  if (attr(x, "space")=="alr_coord"){stop("The matrix is already in the ALR coordinates space.")}
  if (attr(x, "space")=="ilr_coord"){stop("The matrix is in the ILR coordinates space. Matrix should be in the simplex space.")}
  copy = x
  for (i in 1:(dim(x)[1])){
    trans = numeric(dim(x)[2])
    for (j in 1:(dim(x)[2])){
      trans[j]= log(x[i,j]/x[i,R])
    }
    copy[i,] = trans
  }
  copy = copy[,-R]
  attr(copy, "space") <- "alr_coord"
  attr(copy, "reference") <- R
  return(copy)
}
```


## Inverse ALR

```{r}
inversealr = function(x,R=dim(x)[2]+1){ # x = NxD-1 matrix, R original reference variable
  if (is.null(attr(x, "space"))){attr(x, "space") <- "alr_coord"}
  if (attr(x, "space")=="simplex"){stop("The matrix is already in the simplex space.")}
  D_1 = dim(x)[2]
  if (R==(D_1+1)){aumented = cbind(x,numeric(dim(x)[1]))}
  if (R==1){aumented = cbind(numeric(dim(x)[1]),x)}
  if ((R!=(D_1+1)&(R!=1))){aumented = cbind(x[,1:R-1],numeric(dim(x)[1]),x[,R:D_1])}
  res = closure(exp(aumented))
  attr(res,"space") = "simplex"
  attr(res,"reference") = NULL
  return(res)
}
```


## Estimation of the coefficients of any multivariate regression

```{r}
mlm = function(Y,X){ # only the dependent and independent matrices are needed
  ## use solve(t(X),Y) or QR algorithm qr.solve(), cholesky (I HAVE USED QR)
  B = solve(crossprod(X),crossprod(X,Y),tol=1e-21)
  return(B)
}
```

## Varaince-covariance matrix

```{r}
est_var = function(X,Y,B){ # page 146 kevin
  if (missing(B)){B=mlm(Y,X)}
  n=dim(Y)[1]
  sig = (1/n)*t(Y-X%*%B)%*%(Y-X%*%B)
  return(sig)
}
```

## Covariance of parameters (kevin book p145)

```{r}
b_cov = function(X,Y,B){
  sig = est_var(X,Y,B)
  cov = kronecker(sig,solve(t(X)%*%X))
  return(round(cov,5))
}
```

## Transform every variable (ILR or not, not ALR) to ILR

```{r}
var2ilr = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE){ 
  
  # determine if variables are in the simplex or in ILR coordinates
  n_simplex = 0
  n_ilr     = 0
  
  if (is.null(attr(Y,"space"))){
    n_simplex = 1
  }
  
  if (!is.null(attr(Y,"space"))){
    if (attr(Y,"space")=="simplex"){
      n_simplex=1
    }
    else{
      n_ilr=1
    }
  }
  
  for (k in 1:length(X)){
    if (is.null(attr(X[[k]],"space"))){
    n_simplex = n_simplex+1}
    if (!is.null(attr(X[[k]],"space"))){
      if (attr(X[[k]],"space")=="simplex"){
        n_simplex=n_simplex+1
        }
      else{
        n_ilr=n_ilr+1
      }
    }
  }
  
  # case when X, Y is in the simplex
  
  # if V specified
  
  if (!is.na(V[[1]][1,1])){
    if (length(V)!=(1+length(X))){stop("When using the optional argument 'V' it is needed to specify one base matrix for the independent variable and one for each of the q dependent variable in a list that takes the form V = list(V_Y,V_X1...,V_Xq).")}
    }
    
  # if V not specified
  
  if (n_ilr==0){
    if (is.na(V[[1]][1,1])){
      V=list(V_D(dim(Y)[2])) # this the 'standard' contrast matrix for Y
      for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
        V=c(V,list(V_D(dim(X[[i]])[2])))
      }
    }
    
  # now we have V for the simplex variables case
  
  # transform Y into ilr coordinates

  ty = ilr(Y, V[[1]])
    
  # transfrom X to the ilr coordinates
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  }
  
  
  # case where some variables in the simplex, some in ilr
  
  if (min(c(n_simplex,n_ilr))!=0){
    stop("Every variable should be in the same space, whether ilr coordinates or the simplex.")
  }
    
  # every variable in ilr coordinates: V should be specified in the arguments or in the attributes of the data Y,X
  
  if (!is.na(V[[1]][1,1])){
    if (!is.null(attr(Y,"contrast"))){
      equal = TRUE
      for (k in 1:(length(X)+1)){
        if (k==1){
          vk = V[[1]]
          va = attr(Y,"contrast")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
        else{
          vk = V[[k]]
          va = attr(X[[k-1]],"contrast")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
      }
      if (!equal){warning("At least one contrast matrix given in V does not coincide with its analogous in the attributes of the data.\n")}
    }
  }
  
  if (n_simplex==0){
    # construct ty (and recover V if not specified)
    if (is.na(V[[1]][1,1])){
      if (is.null(attr(Y,"contrast"))){
        stop("When using data in the coordinates space, their associated contrast matrices are needed. They can be attached as an attribute of each matrix of data or directly given as an input in V.")}
      else{
        V[[1]]=attr(Y,"contrast")
        for (k in 1:length(X)){V[[k+1]]=attr(X[[k]],"contrast")
        }
      }
    }
    ty = Y
    # construct tx (and recover V)
    tx = matrix(numeric(dim(X[[1]])[1]))+1
    for (k in 1:length(X)){
      tx = cbind(tx,X[[k]])
      }
    if(constant==FALSE){ # should remove the vector of zeros if no constant is required
      tx=tx[,-1]
      }
    if (!is.na(Z[[1]][1,1])){
      for (z in Z){
        tx=cbind(tx,z)
      }
    }
  }
  
  return (list(Y=ty,X=tx,V=V,constant=constant))
}
```

## ILR yx reg

```{r}
# eq 4 ASJ paper (Ngyugen, Laurent, Thomas-Agnan, Ruiz-Gazen)

# VERSION 2.0.0 (with attributes and using the var2ilr function)

ilr_yx_reg = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  input = var2ilr(Y,X,Z,V,constant)
  ty = input$Y
  tx = input$X
  constant = input$constant
  V = input$V
  
  if (dim(ty)[1]<=dim(tx)[2]){
    warning("WARNING: Number of ilr parameters to be estimated greater than sample size \n")
    if (verbose){print(" ")}
  }
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inverseilr(t(Bstar[1,]),V[[1]])
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = V[[1]]%*%t(matrix_x)%*%t(V[[i+1]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz
      c_k = inverseilr(matrix_z, V[[1]])
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="ilr_coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "ilr_coord"
  attr(tx,"contrast") = V[-1]
  
  attr(Bs,"space")="simplex"
  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  
  reslist = list(Y_coord = ty, X_coord = tx, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues)
  attr(reslist,"transformation") = "ILR"
  
  if (!pres){return(reslist)} # return results if not pres
  
  
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    
    # sds
    dimilr = dim(Y)[2]-1
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
    print("--------------------------------------------")
    print(paste("SSR: ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```

## Transform every variable to ALR

```{r}
var2alr = function(Y,X,Z=list(matrix()),R=list(matrix()),constant=TRUE){ 
  
  # determine if variables are in the simplex or in ALR coordinates
  n_simplex = 0
  n_alr     = 0
  
  if (is.null(attr(Y,"space"))){
    n_simplex = 1
  }
  
  if (!is.null(attr(Y,"space"))){
    if (attr(Y,"space")=="simplex"){
      n_simplex=1
    }
    else{
      n_alr=1
    }
  }
  
  for (k in 1:length(X)){
    if (is.null(attr(X[[k]],"space"))){
    n_simplex = n_simplex+1}
    if (!is.null(attr(X[[k]],"space"))){
      if (attr(X[[k]],"space")=="simplex"){
        n_simplex=n_simplex+1
        }
      else{
        n_alr=n_alr+1
      }
    }
  }
  
  # case when X, Y is in the simplex
  
  # if R specified
  
  if (!is.na(R[[1]])){
    if (length(R)!=(1+length(X))){stop("When using the optional argument 'R' it is needed to specify one reference for the independent variable and one for each of the q dependent variable in a list that takes the form R = list(R_Y,R_X1...,R_Xq).")}
    }
    
  # if R not specified
  
  if (n_alr==0){
    if (is.na(R[[1]])){
      R=list(dim(Y)[2])
      for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
        R[[i+1]]=dim(X[[i]])[2]
      }
    }
    
  # now we have R for the simplex variables case
  
  # transform Y into alr coordinates

  ty = alr(Y, R[[1]])
    
  # transfrom X to the alr coordinates
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,alr(X[[i]],R[[i+1]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  }
  
  
  # case where some variables in the simplex, some in alr
  
  if (min(c(n_simplex,n_alr))!=0){
    stop("Every variable should be in the same space, whether alr coordinates or the simplex.")
  }
    
  # every variable in alr coordinates: R should be specified in the arguments or in the attributes of the data Y,X
  
  if (!is.na(R[[1]])){
    if (!is.null(attr(Y,"reference"))){
      equal = TRUE
      for (k in 1:(length(X)+1)){
        if (k==1){
          vk = R[[1]]
          va = attr(Y,"reference")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
        else{
          vk = R[[k]]
          va = attr(R[[k-1]],"reference")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
      }
      if (!equal){warning("At least one alr reference given does not coincide with its analogous in the attributes of the data.\n")}
    }
  }
  
  if (n_simplex==0){
    # construct ty (and recover R if not specified)
    if (is.na(R[[1]])){
      if (is.null(attr(Y,"reference"))){
        stop("When using data in the coordinates space, their associated references list is needed. It can be attached as an attribute of each matrix of data or directly given as an input in R.")}
      else{
        R[[1]]=attr(Y,"reference")
        for (k in 1:length(X)){R[[k+1]]=attr(X[[k]],"reference")
        }
      }
    }
    ty = Y
    # construct tx (and recover V)
    tx = matrix(numeric(dim(X[[1]])[1]))+1
    for (k in 1:length(X)){
      tx = cbind(tx,X[[k]])
      }
    if(constant==FALSE){ # should remove the vector of zeros if no constant is required
      tx=tx[,-1]
      }
    if (!is.na(Z[[1]][1,1])){
      for (z in Z){
        tx=cbind(tx,z)
      }
    }
  }
  
  return (list(Y=ty,X=tx,R=R,constant=constant))
}
```

## P_D matrix

```{r}
P_D = function(D){
  return(rbind(diag(D-1),numeric(D-1)))
}
```

## F_D matrix

```{r}
F_D = function(D){
  fd = diag(D-1)
  fd = cbind(fd, numeric(D-1)-1)
  return(fd)
}
```

## K_D matrix

```{r}
K_D = function(D){
  upm = diag(D-1) - (numeric(D-1)+1)%*%t(numeric(D-1)+1)/D
  down = -t(numeric(D-1)+1)/D
  upm = rbind(upm,down)
  return (upm)
}
```

## Permutation of a column to the last position

```{r}
permutation_D = function(mat,P){ # this function takes as an input a matrix (mat) and position (P) and returns the same matrix but with the column P as the last column, i.e: [x1,x2...,xP,...,xN] -> [x1,x2...,xN,xP]
  D = dim(mat)[2]
  if (D==P){
    return(mat)
  }
  if (1==P){
    return(cbind(mat[,2:D],mat[,1]))
  }
  else{
    return(cbind(mat[,1:(P-1)],mat[,(P+1):D],mat[,P]))
  }
}
```

## Inverse of the permutation

```{r}
inv_permutation_D = function(mat,P){ # undoes the permutation
  D = dim(mat)[2]
  if (D==P){
    return(mat)
  }
  if (1==P){
    return(cbind(mat[,D],mat[,1:(D-1)]))
  }
  else{
    return(cbind(mat[,1:(P-1)],mat[,D],mat[,(P):(D-1)]))
  }
}
```

## ALR yx reg

```{r}
alr_yx_reg = function(Y,X,Z=list(matrix()),R=list(NULL),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of reference variables order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  if (!is.null(R[[1]])){
    Y=permutation_D(Y,R[[1]])
    for (j in 1:length(X)){
      X[[j]]=permutation_D(X[[j]],R[[j+1]])
    input = var2alr(Y,X,Z,constant=constant)
    }
  }
  else{
    input = var2alr(Y,X,Z,constant=constant)
    R=input$R
  }
  
  ty = input$Y
  tx = input$X
  dimy = dim(ty)[2]+1
  constant = input$constant
  
  if (dim(ty)[1]<=dim(tx)[2]){
    warning("WARNING: Number of alr parameters to be estimated greater than sample size \n")
    if (verbose){print(" ")}
  }
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ALR Y-Matrix")
  print(ty)
  print("ALR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inversealr(t(Bstar[1,]),R[[1]])
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the alr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = K_D(dimy)%*%t(matrix_x)%*%F_D(dimx)
    B_q = inv_permutation_D(B_q,R[[i+1]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz
      c_k = inversealr(matrix_z, R[[1]]) # change R[[1]] with the other...
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="alr_coord"
  attr(Bstar,"reference") = R
  
  attr(tx,"space") = "alr_coord"
  attr(tx,"reference") = R[-1]
  
  attr(Bs,"space")="simplex"
  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  
  reslist = list(Y_coord = ty, X_coord = tx, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues)
  attr(reslist,"transformation") = "ALR"
  if (!pres){return(reslist)} # return results if not pres
  
  
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yalr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yalr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfalr = data.frame(Bstar)
    
    
    # sds
    dimalr = dim(Y)[2]-1
    nc = dim(dfalr)[1]
    for (i in dimalr:1){
      if (i==dimalr){dfalr = cbind(dfalr,matrix(nrow=nc))}
      else{
        dfalr = cbind(dfalr[,1:i],matrix(nrow=nc),dfalr[,(i+1):(dim(dfalr)[2])])
      }
    }
    
    dfalr = t(dfalr)
    
    for (i in 1:(dim(bcov)[1])){
      dfalr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfalr = t(dfalr)
    
    rownames(dfalr) = rname
    colnames(dfalr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE COORDINATES):    ")
    print(as.matrix(dfalr))
    print("--------------------------------------------")
    print(paste("SSR: ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```

## yx impacts (ilr)

```{r}
ilr_yx_impacts = function(results){ # the unique argument is the anmes list that comes from the ilr_yx_reg function
    if (attr(results,"transformation")=="ALR"){stop("You are using results from a regression computed used an ALR transformation. Please use 'alr_yx_impacts' function instead. At the end, both results on impacts should be equal.")}
    tx = results$X_coord
    B = results$B_coord
    exp_Yilr = tx%*%B
    Vy = attr(B,"contrast")[[1]]
    exp_Y_simplex = inverseilr(exp_Yilr,Vy)
    I_D = diag(dim(exp_Y_simplex)[2])
    N=dim(exp_Y_simplex)[1]
    Bsimplex = results$B_simplex
    impacts = list()
    for (i in (1:N)){
      W_i = I_D - matrix(1,dim(exp_Y_simplex)[2],1)%*%exp_Y_simplex[i,]
      imp_i = W_i%*%t(Bsimplex)
      impacts[[i]] = t(imp_i)
    }
    return(impacts)
}
```

## yx impacts (alr)

the thing is that from alr results it is needed to use alr_yx_impacts and ilr_yx_impacts is a problem

```{r}
alr_yx_impacts = function(results){ # the unique argument is the named list that comes from the alr_yx_reg function
    if (attr(results,"transformation")=="ILR"){stop("You are using results from a regression computed used an ILR transformation. Please use 'ilr_yx_impacts' function instead. At the end, both results on impacts should be equal.")}
    tx = results$X_coord
    B = results$B_coord
    exp_Yilr = tx%*%B
    Ry = attr(B,"reference")[[1]]
    exp_Y_simplex = inversealr(exp_Yilr,Ry)
    I_D = diag(dim(exp_Y_simplex)[2])
    N=dim(exp_Y_simplex)[1]
    Bsimplex = results$B_simplex
    impacts = list()
    for (i in (1:N)){
      W_i = I_D - matrix(1,dim(exp_Y_simplex)[2],1)%*%exp_Y_simplex[i,]
      imp_i = W_i%*%t(Bsimplex)
      impacts[[i]] = t(imp_i)
      }
    return(impacts)
}
```

## ILR x reg

```{r}
ilr_x_reg = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE toprint with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  ty = Y #already in coordinates
  if (is.na(V[[1]][1,1])){
    for (i in 1:length(X)){
      V[[i]] = V_D(dim(X[[i]])[2])
    }
  }
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  
  if (dim(ty)[1]<=dim(tx)[2]){
    warning("WARNING: Number of ilr parameters to be estimated greater than sample size \n")
    if (verbose){print(" ")}
  }
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=Bstar[1,]
    Bs=rbind(Bs, Bstar[1,])
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = t(matrix_x)%*%t(V[[i]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz
      c_k = matrix_z
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="ilr_coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "ilr_coord"
  attr(tx,"contrast") = V
  
  attr(Bs,"space")="simplex"
  
  reslist = list(Y_coord = ty, constant = constant, X_coord = tx, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov)
  attr(reslist, "transformation") = "ILR"
  
  if (!pres){return(reslist)} # return results if not pres
  
  
  # till here
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    
    # sds
    dimilr = dim(Y)[2]
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
  }
}
```


## ALR x reg

```{r}
alr_x_reg = function(Y,X,Z=list(matrix()),R=list(NULL),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE toprint with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  ty = Y #already in coordinates
  if (is.null(R[[1]])){
    for (i in 1:length(X)){
      R[[i]] = dim(X[[i]])[2]
      X[[i]]=permutation_D(X[[i]],R[[i]])
    }
  }
  
  else{
    for (i in 1:length(X)){
      X[[i]]=permutation_D(X[[i]],R[[i]])
      }
    }
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,alr(X[[i]],R[[i]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  
  if (dim(ty)[1]<=dim(tx)[2]){
    warning("WARNING: Number of alr parameters to be estimated greater than sample size \n")
    if (verbose){print(" ")}
  }
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ALR Y-Matrix")
  print(ty)
  print("ALR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=Bstar[1,]
    Bs=rbind(Bs, Bstar[1,])
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  xdimlist=list()
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    xdimlist[i] = dimx
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = t(matrix_x)%*%F_D(dimx)
    B_q = inv_permutation_D(B_q,R[[i]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz
      c_k = matrix_z
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="alr_coord"
  attr(Bstar,"reference") = R
  
  attr(tx,"space") = "alr_coord"
  attr(tx,"reference") = R
  
  attr(Bs,"space")="simplex"
  
  reslist = list(Y_coord = ty, constant = constant, X_coord = tx, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov, xdim=xdimlist)
  attr(reslist,"transformation") = "ALR"
  if (!pres){return(reslist)} # return results if not pres
  
  
  # till here
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]))){
      cnames = c(cnames, paste("Yalr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yalr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfalr = data.frame(Bstar)
    
    
    
    # sds
    dimalr = dim(Y)[2]
    nc = dim(dfalr)[1]
    for (i in dimalr:1){
      if (i==dimalr){dfalr = cbind(dfalr,matrix(nrow=nc))}
      else{
        dfalr = cbind(dfalr[,1:i],matrix(nrow=nc),dfalr[,(i+1):(dim(dfalr)[2])])
      }
    }
    
    dfalr = t(dfalr)
    
    for (i in 1:(dim(bcov)[1])){
      dfalr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfalr = t(dfalr)
    
    rownames(dfalr) = rname
    colnames(dfalr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ALR SPACE):    ")
    print(as.matrix(dfalr))
  }
}
```

## ilr_x_impacts

```{r}
ilr_x_impacts = function(results){ # the unique argument is the anmes list that comes from the ilr_yx_reg function
    if (attr(results,"transformation")=="ALR"){stop("You are using results from a regression computed used an ALR transformation. Please use 'alr_x_impacts' function instead. At the end, both results on impacts should be equal.")}
    B = results$B_coord
    constant = results$constant
    Vx = attr(B,"contrast")
    if (constant){
      if (dim(B)[2]==1){B=matrix(B[-1,])}
      else{
        B = B[-1,]
      }
    }
    h=1
    impacts=list()
    for (i in 1:length(Vx)){
      dimx = dim(Vx[[i]])[1]
      if (is.null(dim(B))){B=t(matrix(B))}
      bstar = B[h:(h+dimx-2),]
      h=h+dimx-1
      impacts[[i]]=Vx[[i]]%*%bstar
      }
    return(impacts)
}
```

## alr_x_impacts

```{r}
alr_x_impacts = function(results){ # the unique argument is the named list that comes from the ilr_yx_reg function
    if (attr(results,"transformation")=="ILR"){stop("You are using results from a regression computed used an ILR transformation. Please use 'ilr_x_impacts' function instead. At the end, both results on impacts should be equal.")}
    B = results$B_coord
    constant = results$constant
    listxdim = results$xdim
    R = attr(B,"reference")
    if (constant){
      if (dim(B)[2]==1){B=matrix(B[-1,])}
      else{
        B = B[-1,]
      }
    }
    h=1
    impacts=list()
    for (i in 1:length(R)){
      dimx = listxdim[[i]]
      if (is.null(dim(B))){B=t(matrix(B))}
      bstar = B[h:(h+dimx-2),]
      h=h+dimx-1
      impacts[[i]]=t(F_D(dimx))%*%bstar
      }
    return(impacts)
}
```

## ilr_y_reg

```{r}
ilr_y_reg = function(Y,X,V=NaN,constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # X = tx as it is already in coord.
  for (i in 1:length(X)){
    tx = cbind(tx,X[[i]])
    }
  if (constant==FALSE){ # should remove the vector of ones if no constant is required
    tx=tx[,-1]
  }
  
  # transform Y to coordinates
  if (!is.na(V)){ # if V specified as argument
    ty = ilr(Y,V)
  }
  
  else{
    V=V_D(dim(Y)[2]) # if V not specified as argument
    ty=ilr(Y,V)}
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}
  
  Bstar = mlm(ty,tx)
  # bcov = b_cov(tx,ty,Bstar) ######## some problems here
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inverseilr(t(Bstar[1,]),V)
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  if (!is.na(X[[1]][1,1])){
    for (i in 1:length(X)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, X", i, sep=""))}
      dimx = dim(X[[i]])[2]
      matrix_x = Bstar[h:(h+dimx-1),]
      if (h==(h+dimx-1)){matrix_x = t(matrix(Bstar[h,]))}
      if (h!=(h+dimx-1)){matrix_x = Bstar[h:(h+dimx-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimx
      c_k = inverseilr(matrix_x, V)
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="ilr_coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "ilr_coord"
  attr(tx,"contrast") = NaN
  
  attr(Bs,"space")="simplex"
  
  if (!pres){return(list(Y_coord = ty, X_coord = tx, B_coord = Bstar, B_simplex = Bs))} 
# return results if not pres + Bcoord_cov=bcov
  
  
  
  # part of PRES = TRUE
  
  if (pres=="TRUE"){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    
    # sds
    dimilr = dim(Y)[2]-1
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
  }
}
```

## alr_y_reg

```{r}
alr_y_reg = function(Y,X,R=NaN,constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # X = tx as it is already in coord.
  for (i in 1:length(X)){
    tx = cbind(tx,X[[i]])
    }
  if (constant==FALSE){ # should remove the vector of ones if no constant is required
    tx=tx[,-1]
  }
  
  # transform Y to coordinates
  if (!is.na(R)){ # if R specified as argument
    ty = alr(Y,R)
  }
  
  else{
    R=dim(Y)[2] # if R not specified as argument
    ty=alr(Y,R)}
  
  if (verbose){
  print("Y REGRESSION")
  print("===========================")
  
  print("ALR Y-Matrix")
  print(ty)
  print("ALR X-Matrix")
  print(tx)}
  
  Bstar = mlm(ty,tx)
  # bcov = b_cov(tx,ty,Bstar) ######## some problems here
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inversealr(t(Bstar[1,]),R)
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  if (!is.na(X[[1]][1,1])){
    for (i in 1:length(X)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, X", i, sep=""))}
      dimx = dim(X[[i]])[2]
      if (h==(h+dimx-1)){matrix_x = t(matrix(Bstar[h,]))}
      if (h!=(h+dimx-1)){matrix_x = Bstar[h:(h+dimx-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimx
      c_k = inversealr(matrix_x, R)
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="alr_coord"
  attr(Bstar,"reference") = R
  
  attr(tx,"space") = "alr_coord"
  attr(tx,"reference") = NaN
  
  attr(Bs,"space")="simplex"
  
  if (!pres){return(list(Y_coord = ty, X_coord = tx, B_coord = Bstar, B_simplex = Bs))} 
# return results if not pres + Bcoord_cov=bcov
  
  
  # part of PRES = TRUE
  
    if (pres=="TRUE"){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    # B star and sds
    dfilr = data.frame(Bstar)
    
    # sds
    dimilr = dim(Y)[2]-1
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
  }
}
```

## ILR y impacts

```{r}
ilr_y_impacts = function(results){ #results argument regers to the output of ilr_y_reg
  # first we need EY*
  Bcoord = results$B_coord
  Vy = attr(results$Y_coord, "contrast")
  xcoord = results$X_coord
  EYcoord = xcoord%*%Bcoord
  EYsimpl = inverseilr(EYcoord,Vy)
  D = dim(Vy)[1]
  impacts=list()
  for (i in 1:(dim(EYsimpl)[1])){
    Wi = diag(D) - matrix(1,D,1)%*%t(EYsimpl[i,])
    impacts[[i]] = t(Wi%*%Vy%*%t(Bcoord))
  }
  return(impacts)
}
```


## ALR y impacts 

```{r}
alr_y_impacts = function(results){ #results argument regers to the output of ilr_y_reg
  # first we need EY*
  Bcoord = results$B_coord
  R = attr(results$Y_coord, "reference")
  xcoord = results$X_coord
  EYcoord = xcoord%*%Bcoord
  EYsimpl = inversealr(EYcoord,R)
  D = dim(EYcoord)[2]+1
  impacts=list()
  for (i in 1:(dim(EYsimpl)[1])){
    Wi = diag(D) - matrix(1,D,1)%*%t(EYsimpl[i,]) # Wi are the same in both cases
    Wistar = Wi%*%P_D(D) #this is the only important thing that changes
    impacts[[i]] = t(Wistar%*%t(Bcoord))
  }
  return(impacts)
}
```





