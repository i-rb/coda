---
title: "create_package"
output:
  html_notebook:
    toc: yes
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    toc: yes
---

This brief notebook is only to create the package

```{r}
example_matrices = function(){
m1 = rbind(c(0.25,0.3,0.2),c(0.5,0.2,0.3),c(0.9,0.05,0.05),c(0.33,0.4,0.24),c(0.2,0.3,0.5),c(0.91,0.05,0.04),c(0.1,0.7,0.2)) 
m2 = rbind(c(0.1,0.4,0.25,0.25),c(0.3,0.3,0.3,0.1),c(0.9,0.05,0.02,0.03),c(0.1,0.7,0.15,0.05),c(0.8,0.1,0.05,0.05),c(0.35,0.25,0.3,0.1),c(0.4,0.1,0.1,0.4)) 
m3 = matrix(c(23,1,32,12,9,11,3)) 
m4 = rbind(c(0.2,0.8),c(0.3,0.7),c(0.9,0.1),c(0.75,0.25),c(0.3,0.7),c(0.15,0.85),c(0.9,0.1))
m5 = rbind(c(3,-4.3),c(0,-2),c(4,5),c(-2,3), c(4,2), c(1,11), c(23,2))
return(list(m1,m2,m3,m4,m5))}
```

```{r}
m1 = example_matrices()[[1]]
m2 = example_matrices()[[2]]
m3 = example_matrices()[[3]]
m4 = example_matrices()[[4]]
m5 = example_matrices()[[5]]
```

```{r}
impacts(ilr_x_reg(m3,list(m1)))
# list(a = jdie, b= djid)
```

```{r}
load("/Users/ivanrendobarreiro/coda/packageone/data/BDDSegX.RData")
```



```{r}
# this is to delete the past elements in the enviroment
rm(list = ls())
```

# All Defined Functions 

## Closure

```{r}
closure=function(x, k){ # x the NxD matrix, k the constant (k=1 if missing)
  if (missing(k)){
    newx <- (x)/rowSums(x)
    return(newx)
  }
  else{
    newx <- (k*x)/rowSums(x)
    return(newx)
  }
} 
```

## Helmert Matrix for D parts

```{r} 
# Creates de Helmert Matrix given the number of parts of the variable
V_D = function(D){ # D is the dimension (parts)
  V_D = matrix(0L, nrow =D , ncol = D-1)
  for (i in 1:(D-1)){  # pseudodiagonal elements
    V_D[i,i] = (D-i)/(sqrt((D-i+1)*(D-i)))
  }
  for (i in 2:D){ # below pseudodiagonal elements
    for (j in 1:i-1){
      V_D[i,j]=-1/(sqrt((D-j+1)*(D-j)))
    }
  } 
  return(V_D)
}
```

## ILR Transformation

```{r}
ilr = function(x, V){ # x matrix N x D
  if (is.null(attr(x, "space"))){attr(x, "space") <- "simplex"}
  if (attr(x, "space")=="ilr_coord"){stop("The matrix is already in the ILR coordinates space.")}
  if (attr(x, "space")=="alr_coord"){stop("The matrix is in the ALR coordinates space. Matrix should be in the simplex space.")}
  if (missing(V)){V=V_D(dim(x)[2])}
  x = closure(x)
  ilr_mat = t(t(V)%*%t(log(x)))
  attr(ilr_mat, "space") <- "ilr_coord"
  attr(ilr_mat, "contrast") <- V
  return(ilr_mat)
}
```

## Inverse of the ILR

```{r}
inverseilr=function(x,V){
  if (is.null(attr(x, "space"))){attr(x, "space") <- "ilr_coord"}
  if (attr(x, "space")=="simplex"){stop("The matrix is already in the simplex space.")}
  x = t(x)
  if (missing(V)){
    if (is.null(attr(x,"contrast"))){
      V=V_D(dim(x)[1]+1)
    }
    else{V = attr(x,"contrast")}
  }
  inv_mat = closure(t(exp(V%*%x)))
  attr(inv_mat,"space") = "simplex"
  attr(inv_mat,"contrast") = NULL
  return(inv_mat)
}
```

## ALR

```{r}
alr = function(x,R=dim(x)[2]){ # x: N x D matrix, R : Reference (last term by default)
  if (is.null(attr(x, "space"))){attr(x, "space") <- "simplex"}
  if (attr(x, "space")=="alr_coord"){stop("The matrix is already in the ALR coordinates space.")}
  if (attr(x, "space")=="ilr_coord"){stop("The matrix is in the ILR coordinates space. Matrix should be in the simplex space.")}
  copy = x
  for (i in 1:(dim(x)[1])){
    trans = numeric(dim(x)[2])
    for (j in 1:(dim(x)[2])){
      trans[j]= log(x[i,j]/x[i,R])
    }
    copy[i,] = trans
  }
  copy = as.matrix(copy[,-R])
  attr(copy, "space") <- "alr_coord"
  attr(copy, "reference") <- R
  return(copy)
}
```


## Inverse ALR

```{r}
inversealr = function(x,R=dim(x)[2]+1){ # x = NxD-1 matrix, R original reference variable
  if (is.null(attr(x, "space"))){attr(x, "space") <- "alr_coord"}
  if (attr(x, "space")=="simplex"){stop("The matrix is already in the simplex space.")}
  D_1 = dim(x)[2]
  if (R==(D_1+1)){aumented = cbind(x,numeric(dim(x)[1]))}
  if (R==1){aumented = cbind(numeric(dim(x)[1]),x)}
  if ((R!=(D_1+1)&(R!=1))){aumented = cbind(x[,1:R-1],numeric(dim(x)[1]),x[,R:D_1])}
  res = closure(exp(aumented))
  attr(res,"space") = "simplex"
  attr(res,"reference") = NULL
  return(res)
}
```


## Estimation of the coefficients of any multivariate regression

```{r}
mlm = function(Y,X){ # only the dependent and independent matrices are needed
  ## use solve(t(X),Y) or QR algorithm qr.solve(), cholesky (I HAVE USED QR)
  B = solve(crossprod(X),crossprod(X,Y),tol=1e-21)
  return(B)
}
```

## Varaince-covariance matrix

```{r}
est_var = function(X,Y,B){ # page 146 kevin
  if (missing(B)){B=mlm(Y,X)}
  n=dim(Y)[1]
  sig = (1/n)*t(Y-X%*%B)%*%(Y-X%*%B)
  return(sig)
}
```

## Covariance of parameters (kevin book p145)

```{r}
b_cov = function(X,Y,B){
  sig = est_var(X,Y,B)
  cov = kronecker(sig,solve(t(X)%*%X))
  return(cov)
}
```

## Transform every variable (ILR or not, not ALR) to ILR

```{r}
var2ilr = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE){ 
  
  # determine if variables are in the simplex or in ILR coordinates
  n_simplex = 0
  n_ilr     = 0
  
  if (is.null(attr(Y,"space"))){
    n_simplex = 1
  }
  
  if (!is.null(attr(Y,"space"))){
    if (attr(Y,"space")=="simplex"){
      n_simplex=1
    }
    else{
      n_ilr=1
    }
  }
  
  for (k in 1:length(X)){
    if (is.null(attr(X[[k]],"space"))){
    n_simplex = n_simplex+1}
    if (!is.null(attr(X[[k]],"space"))){
      if (attr(X[[k]],"space")=="simplex"){
        n_simplex=n_simplex+1
        }
      else{
        n_ilr=n_ilr+1
      }
    }
  }
  
  # case when X, Y is in the simplex
  
  # if V specified
  
  if (!is.na(V[[1]][1,1])){
    if (length(V)!=(1+length(X))){stop("When using the optional argument 'V' it is needed to specify one base matrix for the independent variable and one for each of the q dependent variable in a list that takes the form V = list(V_Y,V_X1...,V_Xq).")}
    }
    
  # if V not specified
  
  if (n_ilr==0){
    if (is.na(V[[1]][1,1])){
      V=list(V_D(dim(Y)[2])) # this the 'standard' contrast matrix for Y
      for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
        V=c(V,list(V_D(dim(X[[i]])[2])))
      }
    }
    
  # now we have V for the simplex variables case
  
  # transform Y into ilr coordinates

  ty = ilr(Y, V[[1]])
    
  # transform X to the ilr coordinates
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  }
  
  
  # case where some variables in the simplex, some in ilr
  
  if (min(c(n_simplex,n_ilr))!=0){
    stop("Every variable should be in the same space, whether ilr coordinates or the simplex.")
  }
    
  # every variable in ilr coordinates: V should be specified in the arguments or in the attributes of the data Y,X
  
  if (!is.na(V[[1]][1,1])){
    if (!is.null(attr(Y,"contrast"))){
      equal = TRUE
      for (k in 1:(length(X)+1)){
        if (k==1){
          vk = V[[1]]
          va = attr(Y,"contrast")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
        else{
          vk = V[[k]]
          va = attr(X[[k-1]],"contrast")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
      }
      if (!equal){warning("At least one contrast matrix given in V does not coincide with its analogous in the attributes of the data.\n")}
    }
  }
  
  if (n_simplex==0){
    # construct ty (and recover V if not specified)
    if (is.na(V[[1]][1,1])){
      if (is.null(attr(Y,"contrast"))){
        stop("When using data in the coordinates space, their associated contrast matrices are needed. They can be attached as an attribute of each matrix of data or directly given as an input in V.")}
      else{
        V[[1]]=attr(Y,"contrast")
        for (k in 1:length(X)){V[[k+1]]=attr(X[[k]],"contrast")
        }
      }
    }
    ty = Y
    # construct tx (and recover V)
    tx = matrix(numeric(dim(X[[1]])[1]))+1
    for (k in 1:length(X)){
      tx = cbind(tx,X[[k]])
      }
    if(constant==FALSE){ # should remove the vector of zeros if no constant is required
      tx=tx[,-1]
      }
    if (!is.na(Z[[1]][1,1])){
      for (z in Z){
        tx=cbind(tx,z)
      }
    }
  }
  
  return (list(Y=ty,X=tx,V=V,constant=constant))
}
```

## ILR yx reg

```{r}
# eq 4 ASJ paper (Ngyugen, Laurent, Thomas-Agnan, Ruiz-Gazen)


# VERSION 2.0.0 (with attributes and using the var2ilr function)

ilr_yx_reg = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  if (constant){x_col_names = c("intercept")}
  else{x_col_names = c()}
  
  for (i in 1:length(X)){
    if (is.null(colnames(X[[i]]))){
      for (j in 1:(dim(X[[i]])[2])){
        x_col_names = c(x_col_names, paste("X_",i,"_",j,sep=""))
      }
    }
    else{x_col_names = c(x_col_names,colnames(X[[i]]))}
  }
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (is.null(colnames(Z[[i]]))){
      for (j in 1:(dim(Z[[i]])[2])){
        x_col_names = c(x_col_names, paste("Z_",i,"_",j,sep=""))
      }
    }
      else{x_col_names = c(x_col_names,colnames(Z[[i]]))
      }
    }
  }
  
  if (is.null(colnames(Y))){
    y_col_names = c()
    for (i in 1:(dim(Y)[2])){
      y_col_names = c(y_col_names, paste("Y_",i,sep=""))
    }
  }
  else{y_col_names = colnames(Y)}
  
  input = var2ilr(Y,X,Z,V,constant)
  ty = input$Y
  tx = input$X

  if (sum(is.na(ty))>0){stop("There are NAs in the Y variable.")}
  if (sum(is.na(tx))>0){stop("There are NAs in the X variable.")}
  
  constant = input$constant
  V = input$V
  
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inverseilr(t(Bstar[1,]),V[[1]])
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = V[[1]]%*%t(matrix_x)%*%t(V[[i+1]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz
      c_k = inverseilr(matrix_z, V[[1]])
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="ilr_coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "ilr_coord"
  attr(tx,"contrast") = V[-1]
  
  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  colnames(Bs) = y_col_names
  rownames(Bs) = x_col_names
  attr(Bs,"space")="simplex"
  
  reslist = list(Y_coord = ty, X_coord = tx, constant = constant, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues)
  attr(reslist,"reg_type") = "ilr_yx_reg"
  
  if (!pres){return(reslist)} # return results if not pres
  
  
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    
    # sds
    dimilr = dim(Y)[2]-1
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
    print("--------------------------------------------")
    print(paste("n obs  : ", dim(tx)[1], sep="")) 
    print(paste("SSR    : ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```


## Transform every variable to ALR

```{r}
var2alr = function(Y,X,Z=list(matrix()),R=list(matrix()),constant=TRUE){ 
  
  # determine if variables are in the simplex or in ALR coordinates
  n_simplex = 0
  n_alr     = 0
  
  if (is.null(attr(Y,"space"))){
    n_simplex = 1
  }
  
  if (!is.null(attr(Y,"space"))){
    if (attr(Y,"space")=="simplex"){
      n_simplex=1
    }
    else{
      n_alr=1
    }
  }
  
  for (k in 1:length(X)){
    if (is.null(attr(X[[k]],"space"))){
    n_simplex = n_simplex+1}
    if (!is.null(attr(X[[k]],"space"))){
      if (attr(X[[k]],"space")=="simplex"){
        n_simplex=n_simplex+1
        }
      else{
        n_alr=n_alr+1
      }
    }
  }
  
  # case when X, Y is in the simplex
  
  # if R specified
  
  if (!is.na(R[[1]])){
    if (length(R)!=(1+length(X))){stop("When using the optional argument 'R' it is needed to specify one reference for the independent variable and one for each of the q dependent variable in a list that takes the form R = list(R_Y,R_X1...,R_Xq).")}
    }
    
  # if R not specified
  
  if (n_alr==0){
    if (is.na(R[[1]])){
      R=list(dim(Y)[2])
      for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
        R[[i+1]]=dim(X[[i]])[2]
      }
    }
    
  # now we have R for the simplex variables case
  
  # transform Y into alr coordinates

  ty = alr(Y, R[[1]])
    
  # transfrom X to the alr coordinates
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,alr(X[[i]],R[[i+1]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  }
  
  
  # case where some variables in the simplex, some in alr
  
  if (min(c(n_simplex,n_alr))!=0){
    stop("Every variable should be in the same space, whether alr coordinates or the simplex.")
  }
    
  # every variable in alr coordinates: R should be specified in the arguments or in the attributes of the data Y,X
  
  if (!is.na(R[[1]])){
    if (!is.null(attr(Y,"reference"))){
      equal = TRUE
      for (k in 1:(length(X)+1)){
        if (k==1){
          vk = R[[1]]
          va = attr(Y,"reference")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
        else{
          vk = R[[k]]
          va = attr(R[[k-1]],"reference")
          tof = all(dim(vk)==dim(va)) && all(vk==va)
          if (!tof){
            equal = FALSE
          }
        }
      }
      if (!equal){warning("At least one alr reference given does not coincide with its analogous in the attributes of the data.\n")}
    }
  }
  
  if (n_simplex==0){
    # construct ty (and recover R if not specified)
    if (is.na(R[[1]])){
      if (is.null(attr(Y,"reference"))){
        stop("When using data in the coordinates space, their associated references list is needed. It can be attached as an attribute of each matrix of data or directly given as an input in R.")}
      else{
        R[[1]]=attr(Y,"reference")
        for (k in 1:length(X)){R[[k+1]]=attr(X[[k]],"reference")
        }
      }
    }
    ty = Y
    # construct tx (and recover V)
    tx = matrix(numeric(dim(X[[1]])[1]))+1
    for (k in 1:length(X)){
      tx = cbind(tx,X[[k]])
      }
    if(constant==FALSE){ # should remove the vector of zeros if no constant is required
      tx=tx[,-1]
      }
    if (!is.na(Z[[1]][1,1])){
      for (z in Z){
        tx=cbind(tx,z)
      }
    }
  }
  
  return (list(Y=ty,X=tx,R=R,constant=constant))
}
```


## P_D matrix

```{r}
P_D = function(D){
  return(rbind(diag(D-1),numeric(D-1)))
}
```

## F_D matrix

```{r}
F_D = function(D){
  fd = diag(D-1)
  fd = cbind(fd, numeric(D-1)-1)
  return(fd)
}
```

## K_D matrix

```{r}
K_D = function(D){
  upm = diag(D-1) - (numeric(D-1)+1)%*%t(numeric(D-1)+1)/D
  down = -t(numeric(D-1)+1)/D
  upm = rbind(upm,down)
  return (upm)
}
```

## Permutation of a column to the last position

```{r}
permutation_D = function(mat,P){ # this function takes as an input a matrix (mat) and position (P) and returns the same matrix but with the column P as the last column, i.e: [x1,x2...,xP,...,xN] -> [x1,x2...,xN,xP]
  D = dim(mat)[2]
  if (D==P){
    return(mat)
  }
  if (1==P){
    return(cbind(mat[,2:D],mat[,1]))
  }
  else{
    return(cbind(mat[,1:(P-1)],mat[,(P+1):D],mat[,P]))
  }
}
```

## Inverse of the permutation

```{r}
inv_permutation_D = function(mat,P){ # undoes the permutation
  D = dim(mat)[2]
  if (D==P){
    return(mat)
  }
  if (1==P){
    return(cbind(mat[,D],mat[,1:(D-1)]))
  }
  else{
    return(cbind(mat[,1:(P-1)],mat[,D],mat[,(P):(D-1)]))
  }
}
```

## ALR yx reg

```{r}
alr_yx_reg = function(Y,X,Z=list(matrix()),R=list(NULL),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of reference variables order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  if (constant){x_col_names = c("intercept")}
  else{x_col_names = c()}
  
  for (i in 1:length(X)){
    if (is.null(colnames(X[[i]]))){
      for (j in 1:(dim(X[[i]])[2])){
        x_col_names = c(x_col_names, paste("X_",i,"_",j,sep=""))
      }
    }
    else{x_col_names = c(x_col_names,colnames(X[[i]]))}
  }
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (is.null(colnames(Z[[i]]))){
      for (j in 1:(dim(Z[[i]])[2])){
        x_col_names = c(x_col_names, paste("Z_",i,"_",j,sep=""))
      }
    }
      else{x_col_names = c(x_col_names,colnames(Z[[i]]))
      }
    }
  }
  
  if (is.null(colnames(Y))){
    y_col_names = c()
    for (i in 1:(dim(Y)[2])){
      y_col_names = c(y_col_names, paste("Y_",i,sep=""))
    }
  }
  else{y_col_names = colnames(Y)}
  
  
  if (!is.null(R[[1]])){
    Y=permutation_D(Y,R[[1]])
    for (j in 1:length(X)){
      X[[j]]=permutation_D(X[[j]],R[[j+1]])
    input = var2alr(Y,X,Z,constant=constant)
    }
  }
  else{
    input = var2alr(Y,X,Z,constant=constant)
    R=input$R
  }
  
  ty = input$Y
  tx = input$X
  if (sum(is.na(ty))>0){stop("There are NAs in the Y variable.")}
  if (sum(is.na(tx))>0){stop("There are NAs in the X variable.")}
  dimy = dim(ty)[2]+1
  constant = input$constant
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ALR Y-Matrix")
  print(ty)
  print("ALR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inversealr(t(Bstar[1,]),R[[1]])
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the alr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = K_D(dimy)%*%t(matrix_x)%*%F_D(dimx)
    B_q = inv_permutation_D(B_q,R[[i+1]])
    Bs= rbind(Bs, t(B_q))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz
      c_k = inversealr(matrix_z, R[[1]]) # change R[[1]] with the other...
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="alr_coord"
  attr(Bstar,"reference") = R
  
  attr(tx,"space") = "alr_coord"
  attr(tx,"reference") = R[-1]
  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  
  rownames(Bs) = x_col_names
  colnames(Bs) = y_col_names
  attr(Bs,"space")="simplex"
  
  reslist = list(Y_coord = ty, X_coord = tx, constant = constant, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues)
  attr(reslist,"reg_type") = "alr_yx_reg"
  if (!pres){return(reslist)} # return results if not pres
  
  
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yalr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yalr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfalr = data.frame(Bstar)
    
    
    # sds
    dimalr = dim(Y)[2]-1
    nc = dim(dfalr)[1]
    for (i in dimalr:1){
      if (i==dimalr){dfalr = cbind(dfalr,matrix(nrow=nc))}
      else{
        dfalr = cbind(dfalr[,1:i],matrix(nrow=nc),dfalr[,(i+1):(dim(dfalr)[2])])
      }
    }
    
    dfalr = t(dfalr)
    
    for (i in 1:(dim(bcov)[1])){
      dfalr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfalr = t(dfalr)
    
    rownames(dfalr) = rname
    colnames(dfalr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE COORDINATES):    ")
    print(as.matrix(dfalr))
    print("--------------------------------------------")
    print(paste("n obs  : ", dim(tx)[1], sep="")) 
    print(paste("SSR    : ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```

## yx impacts (ilr)

```{r}
ilr_yx_impacts = function(results){ # the unique argument is the named list that comes from the ilr_yx_reg function
    x_names = rownames(results$B_simplex)
    y_names = colnames(results$B_simplex)
    constant = results$constant
    tx = results$X_coord
    B = results$B_coord
    exp_Yilr = tx%*%B
    Vy = attr(B,"contrast")[[1]]
    exp_Y_simplex = inverseilr(exp_Yilr,Vy)
    I_D = diag(dim(exp_Y_simplex)[2])
    N=dim(exp_Y_simplex)[1]
    Bsimplex = results$B_simplex
    impacts = list()
    for (i in (1:N)){
      W_i = I_D - matrix(1,dim(exp_Y_simplex)[2],1)%*%exp_Y_simplex[i,]
      imp_i = t(W_i%*%t(Bsimplex))
      colnames(imp_i) = y_names
      rownames(imp_i) = x_names
      imp_i = imp_i[-1,]
      impacts[[i]] = imp_i
    }
    return(impacts)
}
```


## yx impacts (alr)

the thing is that from alr results it is needed to use alr_yx_impacts and ilr_yx_impacts is a problem

```{r}
alr_yx_impacts = function(results){ # the unique argument is the named list that comes from the alr_yx_reg function
    x_names = rownames(results$B_simplex)
    y_names = colnames(results$B_simplex)
    constant = results$constant
    tx = results$X_coord
    B = results$B_coord
    exp_Yilr = tx%*%B
    Ry = attr(B,"reference")[[1]]
    exp_Y_simplex = inversealr(exp_Yilr,Ry)
    I_D = diag(dim(exp_Y_simplex)[2])
    N=dim(exp_Y_simplex)[1]
    Bsimplex = results$B_simplex
    impacts = list()
    for (i in (1:N)){
      W_i = I_D - matrix(1,dim(exp_Y_simplex)[2],1)%*%exp_Y_simplex[i,]
      imp_i = t(W_i%*%t(Bsimplex))
      colnames(imp_i) = y_names
      rownames(imp_i) = x_names
      imp_i = imp_i[-1,]
      impacts[[i]] = imp_i
      }
    return(impacts)
}
```





## ILR x reg

```{r}
ilr_x_reg = function(Y,X,Z=list(matrix()),V=list(matrix()),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE toprint with a better presentation (name of variables and sd if it is the case) of B and B*.

  if (constant){x_col_names = c("intercept")}
  else{x_col_names = c()}
  
  for (i in 1:length(X)){
    if (is.null(colnames(X[[i]]))){
      for (j in 1:(dim(X[[i]])[2])){
        x_col_names = c(x_col_names, paste("X_",i,"_",j,sep=""))
      }
    }
    else{x_col_names = c(x_col_names,colnames(X[[i]]))}
  }
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (is.null(colnames(Z[[i]]))){
      for (j in 1:(dim(Z[[i]])[2])){
        x_col_names = c(x_col_names, paste("Z_",i,"_",j,sep=""))
      }
    }
      else{x_col_names = c(x_col_names,colnames(Z[[i]]))
      }
    }
  }
  
  if (is.null(colnames(Y))){
    y_col_names = c()
    for (i in 1:(dim(Y)[2])){
      y_col_names = c(y_col_names, paste("Y_",i,sep=""))
    }
  }
  else{y_col_names = colnames(Y)}
  
  ty = Y #already in coordinates
  if (is.na(V[[1]][1,1])){
    for (i in 1:length(X)){
      V[[i]] = V_D(dim(X[[i]])[2])
    }
  }
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  
  if (sum(is.na(ty))>0){stop("There are NAs in the Y variable.")}
  if (sum(is.na(tx))>0){stop("There are NAs in the X variable.")}
  
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = as.matrix(t(matrix(numeric(dim(Y)[2]))))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=Bstar[1,]
    Bs=as.matrix(rbind(Bs, Bstar[1,]))
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = as.matrix(t(matrix_x)%*%t(V[[i]]))
    Bs= as.matrix(rbind(Bs, t(B_q)))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz
      c_k = as.matrix(matrix_z)
      Bs = as.matrix(rbind(Bs, c_k))
      if (verbose){print(c_k)}
    }
  }
  Bs = as.matrix(Bs[-1,])
  attr(Bstar,"space")="ilr_coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "ilr_coord"
  attr(tx,"contrast") = V
  
  Bs = as.matrix(Bs)
  colnames(Bs) = y_col_names
  rownames(Bs) = x_col_names
  attr(Bs,"space")="simplex"
  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  
  
  reslist = list(Y_coord = ty, X_coord = tx, constant = constant, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues)
  attr(reslist, "reg_type") = "ilr_x_reg"
  
  if (!pres){return(reslist)} # return results if not pres
  
  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    
    # sds
    dimilr = dim(Y)[2]
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
    print("--------------------------------------------")
    print(paste("n obs  : ", dim(tx)[1], sep="")) 
    print(paste("SSR    : ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```


## ALR x reg

```{r}
alr_x_reg = function(Y,X,Z=list(matrix()),R=list(NULL),constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  if (constant){x_col_names = c("intercept")}
  else{x_col_names = c()}
  
  for (i in 1:length(X)){
    if (is.null(colnames(X[[i]]))){
      for (j in 1:(dim(X[[i]])[2])){
        x_col_names = c(x_col_names, paste("X_",i,"_",j,sep=""))
      }
    }
    else{x_col_names = c(x_col_names,colnames(X[[i]]))}
  }
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (is.null(colnames(Z[[i]]))){
      for (j in 1:(dim(Z[[i]])[2])){
        x_col_names = c(x_col_names, paste("Z_",i,"_",j,sep=""))
      }
    }
      else{x_col_names = c(x_col_names,colnames(Z[[i]]))
      }
    }
  }
  
  if (is.null(colnames(Y))){
    y_col_names = c()
    for (i in 1:(dim(Y)[2])){
      y_col_names = c(y_col_names, paste("Y_",i,sep=""))
    }
  }
  else{y_col_names = colnames(Y)}
  
  ty = Y #already in coordinates
  if (is.null(R[[1]])){
    for (i in 1:length(X)){
      R[[i]] = dim(X[[i]])[2]
      X[[i]]=permutation_D(X[[i]],R[[i]])
    }
  }
  
  else{
    for (i in 1:length(X)){
      X[[i]]=permutation_D(X[[i]],R[[i]])
      }
    }
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,alr(X[[i]],R[[i]])) # the transformed X is created as a unique matrix
    }
  if (constant==FALSE){ # should remove the vector of zeros if no constant is required
    tx=tx[,-1]
    }
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  
  if (sum(is.na(ty))>0){stop("There are NAs in the Y variable.")}
  if (sum(is.na(tx))>0){stop("There are NAs in the X variable.")}
  
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ALR Y-Matrix")
  print(ty)
  print("ALR X-Matrix")
  print(tx)}

  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=Bstar[1,]
    Bs=rbind(Bs, Bstar[1,])
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  xdimlist=list()
  if (verbose){print("---------------------------")}
  for (i in 1:length(X)){
    if (verbose){print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))}
    # number of parts?
    if (is.null(attr(X[[i]],"space"))){dimx = dim(X[[i]])[2]} #number of parts of this variable i of X D parts --> D-1 param in the ilr 
    if (!is.null(attr(X[[i]],"space"))){
      if (attr(X[[i]],"space")=="simplex"){
        dimx = dim(X[[i]])[2]
      }
      else{dimx = dim(X[[i]])[2]+1}
    }
    xdimlist[i] = dimx
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = t(matrix_x)%*%F_D(dimx)
    B_q = inv_permutation_D(B_q,R[[i]])
    Bs= rbind(Bs, as.matrix(t(B_q)))
    h=h+dimx-1
    if (verbose){print(t(B_q))}
  }
  if (verbose){print("---------------------------")}
  
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))}
      dimz = dim(Z[[i]])[2]
      if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
      if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimz
      c_k = as.matrix(matrix_z)
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = as.matrix(Bs[-1,])
  attr(Bstar,"space")="alr_coord"
  attr(Bstar,"reference") = R
  
  attr(tx,"space") = "alr_coord"
  attr(tx,"reference") = R
  
  Bs = as.matrix(Bs)
  
  colnames(Bs) = y_col_names
  rownames(Bs) = x_col_names
  attr(Bs,"space")="simplex"
  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  
  reslist = list(Y_coord = ty, constant = constant, X_coord = tx, B_coord = Bstar, B_simplex = Bs , Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues, xdim=xdimlist)
  attr(reslist,"reg_type") = "alr_x_reg"
  if (!pres){return(reslist)} # return results if not pres

  
  # part of PRES = TRUE
  
  if (pres){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]))){
      cnames = c(cnames, paste("Yalr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yalr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2]-1)){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }
    
    if (!is.na(Z[[1]][1,1])){
      for (i in 1:length(Z)){
        for (j in 1:(dim(Z[[i]])[2])){
           rname = c(rname, paste("Z",i,j,sep="_"))
        }
      }
    }

    
    # B star and sds
    dfalr = data.frame(Bstar)
    
    
    
    # sds
    dimalr = dim(Y)[2]
    nc = dim(dfalr)[1]
    for (i in dimalr:1){
      if (i==dimalr){dfalr = cbind(dfalr,matrix(nrow=nc))}
      else{
        dfalr = cbind(dfalr[,1:i],matrix(nrow=nc),dfalr[,(i+1):(dim(dfalr)[2])])
      }
    }
    
    dfalr = t(dfalr)
    
    for (i in 1:(dim(bcov)[1])){
      dfalr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfalr = t(dfalr)
    
    rownames(dfalr) = rname
    colnames(dfalr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ALR SPACE):    ")
    print(as.matrix(dfalr))
    print("--------------------------------------------")
    print(paste("n obs  : ", dim(tx)[1], sep="")) 
    print(paste("SSR    : ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```




## check formula

```{r}
check_formula = function(dataset, formula){ # returns a list of X, a list of Y, a list of Z and the type of model that is specified. It also checks that every value is positive, etc (ask Thibault)
  constant = as.logical(attr(terms(formula),"intercept")) 
  compositional_y = FALSE
  ytext = as.character(formula)[2]
  if (substring(ytext,1,6) == "cbind("){
    compositional_y = TRUE
  }
  vars_y = all.vars(formula[[2]])
  Y = as.matrix(dataset[vars_y[[1]]])
  if (length(vars_y)>1){
    for (i in 2:length(vars_y)){
      Y = cbind(Y, as.matrix(dataset[vars_y[[i]]]))  
    }
  } 
  
  compositional_x = FALSE
  xtext = as.character(formula)[3]
  splitted = strsplit(xtext, "\\+|\\-")[[1]]
  numx=1
  numz=1
  X = list() #compo vars
  Z = list() #standard vars
  neg = sum(Y<=0)
  nonumeric = sum(!(is.numeric(Y)))
  nonumeric = nonumeric + sum((is.nan(Y)))
  nonumeric = nonumeric + sum((is.na(Y)))
  
  for (i in splitted){
    temp_text = trimws(i)
    if (!(temp_text=="1" | temp_text=="0")){
        if (!(substring(temp_text,1,6)=="cbind(")){
          Z[[numz]]=as.matrix(dataset[temp_text])
          nonumeric = nonumeric + sum(!(is.numeric(Z[[numz]])))
          nonumeric = nonumeric + sum((is.na(Z[[numz]])))
          nonumeric = nonumeric + sum((is.nan(Z[[numz]])))
          numz = numz + 1
        }
        else{
          compo_text = strsplit(substring(temp_text,7,nchar(temp_text)-1),",")[[1]]
          compo_mat = as.matrix(dataset[trimws(compo_text[1])])
          for (k in 2:length(compo_text)){
            compo_mat = cbind(compo_mat, as.matrix(dataset[trimws(compo_text[k])]))
          }
          X[[numx]] = compo_mat
          neg = neg + sum(X[[numx]]<=0)
          nonumeric = nonumeric + sum(!(is.numeric(X[[numx]])))
          nonumeric = nonumeric + sum((is.nan(X[[numx]])))
          nonumeric = nonumeric + sum((is.na(X[[numx]])))
          numx = numx + 1 
        }
    }
  }
  
  # no negative or 0 values
  if (nonumeric>0){stop("Variables should be numeric and missing values are not admitted.")}
  if (neg>0){stop("Values of endogenous and exogenous variables which are compositional should be strictly positive.")}
  
  # which compositional model?
  
  if (compositional_y == TRUE){
    if (length(X)>0){
      cmodel = "yx_reg"
      if (length(Z)==0){Z=list(matrix())}
    }
    else{
      cmodel = "y_reg"
      X=Z
      Z=list(matrix())
    }
  }
  else{
    if (length(X)>0){
      cmodel = "x_reg"
      if (length(Z)==0){Z=list(matrix())}
    }
    else{
      stop("At least one compositional variable should be used in the model.")
    }
  }
  
  return(list(Y=Y,X=X,Z=Z, model_type = cmodel, constant = constant))
}
```

## general regression function

```{r}
reg = function(dataset, formula, transformation = "ILR", pres=FALSE, V=list(matrix()), R){
  input = check_formula(dataset, formula)
  Y = input$Y
  X = input$X
  Z = input$Z
  constant = input$constant
  model_type = input$model_type
  if (transformation == "ILR"){
    if (model_type == "yx_reg"){
      print("YX-compositional model. ILR transformation. ")
      print("------------------------------------------- ")
      return(ilr_yx_reg(Y=Y,X=X,Z=Z,V=V,constant = constant, pres = pres))
    }
    if (model_type == "x_reg"){
      print("X-compositional model. ILR transformation.  ")
      print("------------------------------------------- ")
      return(ilr_x_reg(Y=Y,X=X,Z=Z,V=V,constant=constant,pres=pres))
    }
    if (model_type == "y_reg"){
      print("Y-compositional model. ILR transformation.  ")
      print("------------------------------------------- ")
      return(ilr_y_reg(Y=Y,X=X,V=V,constant=constant,pres=pres))
    }
  }
  if (transformation == "ALR"){
    if (model_type == "yx_reg"){
      print("YX-compositional model. ALR transformation. ")
      print("------------------------------------------- ")
      if (missing(R)){R=list(NULL)}
      return(alr_yx_reg(Y=Y,X=X,Z=Z,R=R,constant=constant,pres=pres))
    }
    if (model_type == "x_reg"){
      print("X-compositional model. ALR transformation.  ")
      print("------------------------------------------- ")
      if (missing(R)){R=list(NULL)}
      return(alr_x_reg(Y=Y,X=X,Z=Z,R=R,constant=constant,pres=pres))
    }
    if (model_type == "y_reg"){
      print("Y-compositional model. ALR transformation.  ")
      print("------------------------------------------- ")
      if (missing(R)){R=NaN}
      return(alr_y_reg(Y=Y,X=X,R=R,constant=constant,pres=pres))
    }
  }
}
```


## ilr_x_impacts

```{r}
ilr_x_impacts = function(results){ # the unique argument is the named list that comes from the ilr_x_reg function
    B = results$B_coord
    xnames = rownames(results$B_simplex)
    ynames = colnames(results$B_simplex)
    constant = results$constant
    if (constant){xnames = xnames[-1]}
    Vx = attr(B,"contrast")
    if (constant){
      if (dim(B)[2]==1){B=matrix(B[-1,])}
      else{
        B = B[-1,]
      }
    }
    h=1
    impacts=list()
    for (i in 1:length(Vx)){
      dimx = dim(Vx[[i]])[1]
      if (is.null(dim(B))){B=t(matrix(B))}
      bstar = B[h:(h+dimx-2),]
      h=h+dimx-1
      impacts[[i]]=Vx[[i]]%*%bstar
    }
    cc=1
    for (k in (1:length(impacts))){
      val = impacts[[k]]
      ldimx = dim(val)[1]
      colnames(val) = ynames
      rownames(val) = xnames[cc:(cc+ldimx-1)]
      cc = cc + ldimx
      impacts[[k]] = val
    }
    ## part of pooling impacts into a single matrix 
    impacts_mat = impacts[[1]]
    if (length(impacts)>1){
      for (j in (2:length(impacts))){
        impacts_mat = rbind(impacts_mat, impacts[[j]])
      }
    }
    return(impacts_mat)
    return(impacts)
}
```


- INTRODUCE ALSO: (1) 
  impacts of Z variables in the impacts(ilr_x_reg(...))
  
- MEETING (3)

- PERSONALIZATION ISSUE (4)
- CONSTANT ISSUE (5)


## alr_x_impacts

```{r}
alr_x_impacts = function(results){ # the unique argument is the named list that comes from the ilr_yx_reg function
    B = results$B_coord
    xnames = rownames(results$B_simplex)
    ynames = colnames(results$B_simplex)
    constant = results$constant
    if (constant){xnames = xnames[-1]}
    listxdim = results$xdim
    R = attr(B,"reference")
    if (constant){
      if (dim(B)[2]==1){B=matrix(B[-1,])}
      else{
        B = B[-1,]
      }
    }
    h=1
    impacts=list()
    for (i in 1:length(R)){
      dimx = listxdim[[i]]
      if (is.null(dim(B))){B=t(matrix(B))}
      bstar = B[h:(h+dimx-2),]
      h=h+dimx-1
      impacts[[i]]=t(F_D(dimx))%*%bstar
    }
    cc=1
    for (k in (1:length(impacts))){
      val = impacts[[k]]
      ldimx = dim(val)[1]
      colnames(val) = ynames
      rownames(val) = xnames[cc:(cc+ldimx-1)]
      cc = cc + ldimx
      impacts[[k]] = val
    }
    ## part of pooling impacts into a single matrix 
    impacts_mat = impacts[[1]]
    if (length(impacts)>1){
      for (j in (2:length(impacts))){
        impacts_mat = rbind(impacts_mat, impacts[[j]])
      }
    }
    return(impacts_mat)
}
```

## ilr_y_reg

```{r}
ilr_y_reg = function(Y,X,V=NaN,constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.
  
  if (constant){x_col_names = c("intercept")}
  else{x_col_names = c()}
  
  for (i in 1:length(X)){
    if (is.null(colnames(X[[i]]))){
      for (j in 1:(dim(X[[i]])[2])){
        x_col_names = c(x_col_names, paste("X_",i,"_",j,sep=""))
      }
    }
    else{x_col_names = c(x_col_names,colnames(X[[i]]))}
  }
  
  if (is.null(colnames(Y))){
    y_col_names = c()
    for (i in 1:(dim(Y)[2])){
      y_col_names = c(y_col_names, paste("Y_",i,sep=""))
    }
  }
  else{y_col_names = colnames(Y)}
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # X = tx as it is already in coord.
  for (i in 1:length(X)){
    tx = cbind(tx,X[[i]])
    }
  if (constant==FALSE){ # should remove the vector of ones if no constant is required
    tx=tx[,-1]
  }
  
  # transform Y to coordinates
  if (!is.na(V)){ # if V specified as argument
    ty = ilr(Y,V)
  }
  
  else{
    V=V_D(dim(Y)[2]) # if V not specified as argument
    ty=ilr(Y,V)}
  
  if (sum(is.na(ty))>0){stop("There are NAs in the Y variable.")}
  if (sum(is.na(tx))>0){stop("There are NAs in the X variable.")}
  
  if (verbose){
  print("yx REGRESSION")
  print("===========================")
  
  print("ILR Y-Matrix")
  print(ty)
  print("ILR X-Matrix")
  print(tx)}
  
  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar) 
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inverseilr(t(Bstar[1,]),V)
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  if (!is.na(X[[1]][1,1])){
    for (i in 1:length(X)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, X", i, sep=""))}
      dimx = dim(X[[i]])[2]
      matrix_x = Bstar[h:(h+dimx-1),]
      if (h==(h+dimx-1)){matrix_x = t(matrix(Bstar[h,]))}
      if (h!=(h+dimx-1)){matrix_x = Bstar[h:(h+dimx-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimx
      c_k = inverseilr(matrix_x, V)
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="ilr_coord"
  attr(Bstar,"contrast") = V
  
  attr(tx,"space") = "ilr_coord"
  attr(tx,"contrast") = NaN
  

  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  colnames(Bs) = y_col_names
  rownames(Bs) = x_col_names
  attr(Bs,"space")="simplex"
  
  list_return = list(Y_coord = ty, X_coord = tx, constant = constant, B_coord = Bstar, B_simplex = Bs, Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues)
  attr(list_return, "reg_type") = "ilr_y_reg"
  
  if (!pres){return(list_return)} 
# return results if not pres + Bcoord_cov=bcov
  
  # part of PRES = TRUE
  
  if (pres=="TRUE"){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    # sds
    dimilr = dim(Y)[2]-1
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
    print("--------------------------------------------")
    print(paste("n obs  : ", dim(tx)[1], sep="")) 
    print(paste("SSR    : ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```


## alr_y_reg

```{r}
alr_y_reg = function(Y,X,R=NaN,constant=TRUE, verbose=FALSE, pres=FALSE){ # Y dependent, X indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...) 
# pres = TRUE to print with a better presentation (name of variables and sd if it is the case) of B and B*.

  
  if (constant){x_col_names = c("intercept")}
  else{x_col_names = c()}
  
  for (i in 1:length(X)){
    if (is.null(colnames(X[[i]]))){
      for (j in 1:(dim(X[[i]])[2])){
        x_col_names = c(x_col_names, paste("X_",i,"_",j,sep=""))
      }
    }
    else{x_col_names = c(x_col_names,colnames(X[[i]]))}
  }
  
  if (is.null(colnames(Y))){
    y_col_names = c()
    for (i in 1:(dim(Y)[2])){
      y_col_names = c(y_col_names, paste("Y_",i,sep=""))
    }
  }
  else{y_col_names = colnames(Y)}
  
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # X = tx as it is already in coord.
  for (i in 1:length(X)){
    tx = cbind(tx,X[[i]])
    }
  if (constant==FALSE){ # should remove the vector of ones if no constant is required
    tx=tx[,-1]
  }
  
  # transform Y to coordinates
  if (!is.na(R)){ # if R specified as argument
    ty = alr(Y,R)
  }
  
  else{
    R=dim(Y)[2] # if R not specified as argument
    ty=alr(Y,R)}
  
  if (sum(is.na(ty))>0){stop("There are NAs in the Y variable.")}
  if (sum(is.na(tx))>0){stop("There are NAs in the X variable.")}
  
  if (verbose){
  print("Y REGRESSION")
  print("===========================")
  
  print("ALR Y-Matrix")
  print(ty)
  print("ALR X-Matrix")
  print(tx)}
  
  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar) 
  Bs = t(matrix(numeric(dim(Y)[2])))
  
  if (verbose){
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")}
  if (constant==TRUE){
    b0=inversealr(t(Bstar[1,]),R)
    Bs = rbind(Bs, b0)
    if (verbose){
    print("b0 in the simplex:")
    print(b0)}
  }
  h=2
  if (verbose){print("---------------------------")}
  if (!is.na(X[[1]][1,1])){
    for (i in 1:length(X)){
      if (verbose){print(paste("B (in the simplex) for the non-comp. variable, X", i, sep=""))}
      dimx = dim(X[[i]])[2]
      if (h==(h+dimx-1)){matrix_x = t(matrix(Bstar[h,]))}
      if (h!=(h+dimx-1)){matrix_x = Bstar[h:(h+dimx-1),]} # it is non comp, it does not lose a dimension in the transformation
      h=h+dimx
      c_k = inversealr(matrix_x, R)
      Bs = rbind(Bs, c_k)
      if (verbose){print(c_k)}
    }
  }
  Bs = Bs[-1,]
  attr(Bstar,"space")="alr_coord"
  attr(Bstar,"reference") = R
  
  attr(tx,"space") = "alr_coord"
  attr(tx,"reference") = NaN
  
  
  fittedvalues = tx%*%Bstar
  resid = ty- fittedvalues
  attr(resid,"space") = NULL
  attr(resid,"contrast") = NULL
  
  colnames(Bs) = y_col_names
  rownames(Bs) = x_col_names
  attr(Bs,"space")="simplex"
  
  list_return = list(Y_coord = ty, X_coord = tx, constant=constant, B_coord = Bstar, B_simplex = Bs, Bcoord_cov=bcov, residuals_coord = resid, fitted_v_coord = fittedvalues)
  attr(list_return, "reg_type") = "alr_y_reg"
  
  
  if (!pres){return(list_return)} 
# return results if not pres + Bcoord_cov=bcov
  
  
# part of PRES = TRUE
  
if (pres=="TRUE"){
    dfsimplex = data.frame(Bs)
    name=c()
    for (i in 1:(dim(Y)[2])){
      name = c(name, paste("Y_", i, sep=""))
    }
    colnames(dfsimplex)=name
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
      }
    }
    
    rownames(dfsimplex)=rname
    
    cnames = c()
    for (i in (1:(dim(Y)[2]-1))){
      cnames = c(cnames, paste("Yilr_",i,sep=""))
      cnames = c(cnames, paste("(sd_Yilr_",i,")",sep=""))
    }
    
    rname = c()
    if (constant){rname = c(rname, "intercept")}
    for (i in 1:length(X)){
      for (j in 1:(dim(X[[i]])[2])){
        rname = c(rname, paste("X",i,j,sep="_"))
          }
        }

    
    # B star and sds
    dfilr = data.frame(Bstar)
    
    
    # sds
    dimilr = dim(Y)[2]-1
    nc = dim(dfilr)[1]
    for (i in dimilr:1){
      if (i==dimilr){dfilr = cbind(dfilr,matrix(nrow=nc))}
      else{
        dfilr = cbind(dfilr[,1:i],matrix(nrow=nc),dfilr[,(i+1):(dim(dfilr)[2])])
      }
    }
    
    dfilr = t(dfilr)
    
    for (i in 1:(dim(bcov)[1])){
      dfilr[2*i] = sqrt(bcov[i,i]) # standard deviation as sqrt of var
    }
    dfilr = t(dfilr)
    
    rownames(dfilr) = rname
    colnames(dfilr) = cnames
    
    
    print("      B (COEFFICIENTS IN THE SIMPLEX):      ")
    print(as.matrix(dfsimplex))
    print("--------------------------------------------")
    print("     B* (COEF. and SD IN THE ILR SPACE):    ")
    print(as.matrix(dfilr))
    print("--------------------------------------------")
    print(paste("n obs  : ", dim(tx)[1], sep="")) 
    print(paste("SSR    : ", sum(resid^2), sep="")) # sum of squared residuals
  }
}
```

## ILR y impacts

```{r}
ilr_y_impacts = function(results){ #results argument regers to the output of ilr_y_reg
  # first we need EY*
  ccnames = colnames(results$B_simplex)
  rcnames = rownames(results$B_simplex)
  constant = results$constant
  Bcoord = results$B_coord
  Vy = attr(results$Y_coord, "contrast")
  xcoord = results$X_coord
  EYcoord = xcoord%*%Bcoord
  EYsimpl = inverseilr(EYcoord,Vy)
  D = dim(Vy)[1]
  impacts=list()
  for (i in 1:(dim(EYsimpl)[1])){
    Wi = diag(D) - matrix(1,D,1)%*%t(EYsimpl[i,])
    imp = t(Wi%*%Vy%*%t(Bcoord))
    colnames(imp) = ccnames
    rownames(imp) = rcnames
    if (constant){
        if (dim(imp)[1]==2){ 
          imp = t(as.matrix(imp)[-1,])
          rownames(imp) = c(rcnames[[2]])
        }
        else{
          imp = imp[-1,]
        }
      }
    impacts[[i]] = imp
  }
  return(impacts)
}
```



## ALR y impacts 

```{r}
alr_y_impacts = function(results){ #results argument regers to the output of ilr_y_reg
  # first we need EY*
  constant = results$constant
  Bcoord = results$B_coord
  coln = colnames(results$B_simplex)
  rown = rownames(results$B_simplex)
  R = attr(results$Y_coord, "reference")
  xcoord = results$X_coord
  EYcoord = xcoord%*%Bcoord
  EYsimpl = inversealr(EYcoord,R)
  D = dim(EYcoord)[2]+1
  impacts=list()
  for (i in 1:(dim(EYsimpl)[1])){
    Wi = diag(D) - matrix(1,D,1)%*%t(EYsimpl[i,]) # Wi are the same in both cases
    Wistar = Wi%*%P_D(D) #this is the only important thing that changes
    tempres = t(Wistar%*%t(Bcoord))
    colnames(tempres) = coln
    rownames(tempres) = rown
    if (constant){
      if (dim(tempres)[1]==2){ 
          tempres = t(as.matrix(tempres)[-1,])
          rownames(tempres) = c(rown[[2]])
        }
        else{
          tempres = tempres[-1,]
        }
      }
    
    impacts[[i]] = tempres
  }
  return(impacts)
}
```


## general impacts function

```{r}
impacts = function(results){
  if (attr(results,"reg_type")=="alr_x_reg"){return(alr_x_impacts(results))}
  if (attr(results,"reg_type")=="alr_y_reg"){return(alr_y_impacts(results))}
  if (attr(results,"reg_type")=="alr_yx_reg"){return(alr_yx_impacts(results))}
  if (attr(results,"reg_type")=="ilr_x_reg"){return(ilr_x_impacts(results))}
  if (attr(results,"reg_type")=="ilr_y_reg"){return(ilr_y_impacts(results))}
  if (attr(results,"reg_type")=="ilr_yx_reg"){return(ilr_yx_impacts(results))}
  else{stop("Input in 'impacts()' function is not a valid output of one of the regression functions.")}
}
```


## summary for impacts (only for yx and y models. For x models it makes no sense.)

```{r}
imp_summary = function(impact_results){
  ynames = colnames(impact_results[[1]])
  xnames = rownames(impact_results[[1]])
  ncols = length(ynames)*length(xnames)
  xaxis = numeric(ncols)
  cc=1
  for (i in xnames){
    for (j in ynames){
      xaxis[cc] = paste(i,j,sep=" -> ") #to?
      cc=cc+1
    }
  }
  resmat = matrix(0,ncols,6)
  rownames(resmat) = xaxis
  colnames(resmat) = c("Mean", "Min.", "q1 (25%)", "q2 (50%)", "q3 (75%)", "Max.")
  qq=1
  for (i in 1:length(xnames)){
    for (j in 1:length(ynames)){
      values = numeric(length(impact_results))
      for (n in 1:length(impact_results)){
        values[n] = impact_results[[n]][i,j]
      }
      resmat[qq,1] = mean(values)
      resmat[qq,2] = min(values)
      resmat[qq,3] = quantile(values,0.25)
      resmat[qq,4] = quantile(values,0.5)
      resmat[qq,5] = quantile(values,0.75)
      resmat[qq,6] = max(values)
      qq=qq+1
    }
  }
  return(resmat)
}
```

```{r}
share_ratio_summary = function(results){
  Bs = results$B_simplex
  xnames = rownames(Bs)
  constant = results$constant
  if (constant){
    if (dim(Bs)[1]==2){
      Bs = t(as.matrix(Bs[-1,]))
      rownames(Bs) = c(xnames[[2]])}
    else{Bs = as.matrix(Bs[-1,])}
  }
  res=list()
  P = (dim(Bs)[1])
  for (k in 1:P){
    dimy = dim(Bs)[2]
    matres = matrix(0,dimy,dimy)
    for (i in 1:dimy){
      for (j in 1:dimy){
        matres[i,j] = log(Bs[k,j]/Bs[k,i])
      }
    }
    colnames(matres) = colnames(Bs)
    rownames(matres) = colnames(Bs)
    res[[xnames[[k+1]]]] = matres
  }
  return(res)
}
```


