---
title: "Package Functions (Week 3)"
output:
  html_notebook:
    toc: yes
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    toc: yes
---

# Preliminary Functions (format, maybe warnings and so)

# Operations Functions

## Closure Operator

```{r}
C=function(x, k){ # x the NxD matrix, k the constant (k=1 if missing)
  if (missing(k)){
    newx <- (x)/rowSums(x)
    return(newx)
  }
  else{
    newx <- (k*x)/rowSums(x)
    return(newx)
  }
} 
```


# Transformation functions (ilr, inverseolr,...)

## Function that creates the Helmert Matrix

If $V$ (contrast matrix) is not passed, computations are done with the Helmert Matrix as default.

```{r} 
# Creates de Helmert Matrix given the number of parts of the variable
V_D = function(D){ # D is the dimension (parts)
  V_D = matrix(0L, nrow =D , ncol = D-1)
  for (i in 1:(D-1)){  # pseudodiagonal elements
    V_D[i,i] = (D-i)/(sqrt((D-i+1)*(D-i)))
  }
  for (i in 2:D){ # below pseudodiagonal elements
    for (j in 1:i-1){
      V_D[i,j]=-1/(sqrt((D-j+1)*(D-j)))
    }
  } 
  return(V_D)
}
```

## ILR transformation

Given a matrix NxD and a V contrast matrix, the function returns the ilr-transformed coordinates in a matrix.

```{r}
ilr = function(x, V){ # x matrix N x D
  if (missing(V)){V=V_D(dim(x)[2])}
  x = C(x)
  return(t(t(V)%*%t(log(x))))
}
```


```{r}
m1 = matrix(c(0.25,0.249999,0.2,0.2))
m1 <- cbind(m1, c(0.3, 0.3, 0.3, 0.35))
m1 <- cbind(m1, c(0.45, 0.45, 0.5, 0.45)) # definig the comp matrix
```


## Inverse of the Ilr

```{r}
inverseilr=function(x,V){
  x = t(x)
  if (missing(V)){V=V_D(dim(x)[1]+1)}
  return(C(t(exp(V%*%x))))
}
```



# Functions for the Regression

## Estimation of the coefficients

Given the model: $\begin{pmatrix} y_1\\ y_2\\ ...\\ y_{p}\end{pmatrix} = D\begin{pmatrix}\beta_1\\\beta_2\\...\\ \beta_{p}\end{pmatrix} + \begin{pmatrix}u_1\\u_2\\...\\ u_{p} \end{pmatrix}$

The BLUE estimator of $B$ is obtained computing: 

$\hat{B} = (X^TX)^{-1}X^TY$

```{r}
mlm = function(Y,X){ # only the dependent and independent matrices are needed
  ## use solve(t(X),Y) or QR algorithm qr.solve(), cholesky (I HAVE USED QR)
  B = qr.solve(t(X)%*%X,t(X)%*%Y)
  return(round(B,8))
}
```

```{r}
mlm(m2,m1)
```

## Estimation of the variance


### Function 20. Variance-covariance matrices.

In order to obtain the estimator of the variance matrix of the parameters, first it is needed to estimate the common covariance structure $\Sigma$. Recall that $\mathrm{cov}(Y)=I_n\otimes \Sigma$. Then: 

$\hat{\Sigma}=\dfrac{Y'(I-X(X'X)^{-1}X')Y}{n}=\dfrac{(Y-X\hat{B})'(Y-X\hat{B})}{n}$

```{r}
est_var = function(X,Y,B){ # page 146 kevin
  if (missing(B)){B=mlm(Y,X)}
  n=dim(Y)[1]
  sig = (1/n)*t(Y-X%*%B)%*%(Y-X%*%B)
  return(sig)
}
```

Now we can use the $\mathrm{cov}(\hat{\beta})$ estimator from the Kevin book:

```{r}
# p 145 Kevin (5.13)

b_cov = function(X,Y,B){
  sig = est_var(X,Y,B)
  cov = kronecker(sig,solve(t(X)%*%X))
  return(round(cov,5))
}

```


## Compositional Regressions 

### xy reg (coefficients est.)

Assume we have $k$ explanatory variables (some compositional and some not) and $N$ observations. The dependent variable $Y$ can be compositional or not. In this first version there are four inputs: $Y$, the independent variable which can be compositional (comp=1) or not (comp=0), X is the list of non compositional variables and Z the list of compositional variables. Each variable inside the list is a matrix nxD (Dâ‰¥1 the number of parts).

Recall that the regression in the ILR coordinate space is defined by:

$\mathrm{ilr}(\mathbf{Y}_i) = \mathbf{b}_0^*+ \sum_{q=1}^Q\mathrm{ilr}(\mathbf{X}_{qi})\mathbf{B}^*_q + \sum_{k=1}^K Z_{ki} \mathbf{b}^*_k + \mathrm{ilr}(\epsilon_i)$


```{r} 
# eq 4 ASJ paper (Ngyugen, Laurent, Thomas-Agnan, Ruiz-Gazen)

xy_reg = function(Y,X=list(matrix()),Z=list(matrix()),V=list(matrix()),c=TRUE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...)
   print("XY REGRESSION")
   print("===========================")
   if (is.na(V[[1]][1,1])){
    V=list(V_D(dim(Y)[2])) # can I upgrade this with that thing of Thibault? numeric(n) better than numeric()?
    # this the 'standard' contrast matrix for Y
    for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
      V=c(V,list(V_D(dim(X[i][[1]])[2]))) 
    }
  }
  # here I transform the Y and X to the space of coordinates
  ty = ilr(Y, V[[1]])
  dimD=dim(Y)[2]
  tx = matrix(numeric(dim(X[[1]])[1]*(dimD-1)),dim(X[[1]])[1])+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
  }
  if(c==FALSE){
    tx=tx[,dimD:dim(tx)[2]]
    } # should remove the vector of zeros
  # adding constant Z to the independant variables in the coordinate space
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  Bstar = mlm(ty,tx)
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")
  h=1
  if (c==TRUE){
    b0=inverseilr(Bstar[h:(dimD-1),],V[[1]])
    print("b0 in the simplex:")
    print(b0)
  }
  h=dimD
  if (c==FALSE){
    h=1
  }
  print("---------------------------")
  for (i in 1:length(X)){
    print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))
    dimx = dim(X[[i]])[2] #number of parts of this variable i of X D parts --> D-1 param in B*
    matrix_x = Bstar[h:(h+dimx-2),]
    B_q = V[[1]]%*%matrix_x%*%t(V[[i+1]])
    h=h+dimx-1
    print(B_q)
  }
  print("---------------------------")
  for (i in 1:length(Z)){
    print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))
    dimz = dim(Z[[i]])[2]
    matrix_z = Bstar[h:(h+dimz-1),] # it is non comp, it does not lose a dimension in the transformation
    h=h+dimz-1
    c_k = inverseilr(matrix_z, V[[1]])
    print(c_k)
  }
}
```


```{r}
m1 = rbind(c(0.25,0.75),c(0.5,0.5),c(0.9,0.1),c(0.33,0.64),c(0.2,0.8),c(0.91,0.09)) # 2 parts, n=4
m2 = rbind(c(0.1,0.4,0.5),c(0.3,0.3,0.4),c(0.9,0.05,0.05),c(0.1,0.7,0.2),c(0.8,0.1,0.1),c(0.35,0.25,0.4)) # 2 parts, n=4
m3 = matrix(c(23,1,32,12,9,11)) # 2 parts, n=4
```

xy_reg works quite well. To do:

- be sure that it works with different lenghts of the lists of inputs (specially when there is no Z and things like that). We can assume that at least Y and X should be passed (as it is a xy compositional reg).

- add covariance and those things of the mvn package. (copy its report, but no testing)


```{r}
xy_reg(Y = m1, X = list(m2), Z = list(m3), c=TRUE)
```


### y reg

```{r}
y_reg = function(Y,Z=list(matrix()),V=list(matrix()),c=TRUE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices (only one matrix). order: (Y)
  print("Y REGRESSION")
  print("===========================")
   if (is.na(V[[1]][1,1])){
    V=list(V_D(dim(Y)[2])) 
    # this the 'standard' contrast matrix for Y
    }
  # here I transform the Y to the space of coordinates
  ty = ilr(Y, V[[1]])
  dimD=dim(Y)[2]
  tx = matrix(numeric(dim(Z[[1]])[1]*(dimD-1)),dim(Z[[1]])[1])+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  if(c==FALSE){
    tx=tx[,dimD:dim(tx)[2]]
    } # should remove the vector of zeros
  # adding constant Z to the independant variables in the coordinate space
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  Bstar = mlm(ty,tx)
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")
  h=1
  if (c==TRUE){
    b0=inverseilr(Bstar[h:(dimD-1),],V[[1]])
    print("b0 in the simplex:")
    print(b0)
  }
  h=dimD
  if (c==FALSE){
    h=1
  }
  print("---------------------------")
  for (i in 1:length(Z)){
    print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))
    dimz = dim(Z[[i]])[2]
    matrix_z = Bstar[h:(h+dimz-1),] # it is non comp, it does not lose a dimension in the transformation
    h=h+dimz-1
    c_k = inverseilr(matrix_z, V[[1]])
    print(c_k)
  }
}

```

I feel that this would works if xy_reg works. It is only a particular case

```{r}
y_reg(Y=m1, Z=list(m3), c=TRUE)
```

### x reg

**To be done**. If the xy-reg is perfectly done, it would be easier to particularize to x_reg. Moreover, may we have only one function for the regression? Something like: 

```
reg(Y=..., X=..., Z=,..., Ycomp=TRUE/FALSE, c=TRUE/FALSE) # where Ycomp indicates whether Y should be understood or not as a compositional variable.
```

### Adding variance of the parameters (xyreg2)


```{r} 
# eq 4 ASJ paper (Ngyugen, Laurent, Thomas-Agnan, Ruiz-Gazen)

xy_reg2 = function(Y,X=list(matrix()),Z=list(matrix()),V=list(matrix()),c=TRUE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...)
   print("XY REGRESSION")
   print("===========================")
   if (is.na(V[[1]][1,1])){
    V=list(V_D(dim(Y)[2])) # can I upgrade this with that thing of Thibault? numeric(n) better than numeric()?
    # this the 'standard' contrast matrix for Y
    for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
      V=c(V,list(V_D(dim(X[i][[1]])[2]))) 
    }
  }
  # here I transform the Y and X to the space of coordinates
  ty = ilr(Y, V[[1]])
  dimD=dim(Y)[2]
  tx = matrix(numeric(dim(X[[1]])[1]*(dimD-1)),dim(X[[1]])[1])+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
  }
  if(c==FALSE){
    tx=tx[,dimD:dim(tx)[2]]
    } # should remove the vector of zeros
  # adding constant Z to the independant variables in the coordinate space
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  Bstar = mlm(ty,tx)
  covb = b_cov(tx,ty,Bstar)
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")
  h=1
  if (c==TRUE){
    b0=inverseilr(Bstar[h:(dimD-1),],V[[1]])
    print("b0 in the simplex:")
    print(b0)
  }
  h=dimD
  if (c==FALSE){
    h=1
  }
  print("---------------------------")
  print("Variance matrix of the parameters:")
  print(covb)
  print("===========================")
  for (i in 1:length(X)){
    print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))
    dimx = dim(X[[i]])[2] #number of parts of this variable i of X D parts --> D-1 param in B*
    matrix_x = Bstar[h:(h+dimx-2),]
    B_q = V[[1]]%*%matrix_x%*%t(V[[i+1]])
    h=h+dimx-1
    print(B_q)
  }
  print("---------------------------")
  for (i in 1:length(Z)){
    print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))
    dimz = dim(Z[[i]])[2]
    matrix_z = Bstar[h:(h+dimz-1),] # it is non comp, it does not lose a dimension in the transformation
    h=h+dimz-1
    c_k = inverseilr(matrix_z, V[[1]])
    print(c_k)
  }
}
```


```{r}
xy_reg2(Y = m1, X = list(m2), Z = list(m3), c=TRUE)
```

I guess this is more or less all the info we would like to present, but with a different format.



## Copying the (format of) mvn package. It is not, mvn is it?

Two ways of output: ilr (default) or simplex spaces. I'll construct -by the moment- the former (xy_reg3). This is the 


```{r} 
# eq 4 ASJ paper (Ngyugen, Laurent, Thomas-Agnan, Ruiz-Gazen)

xy_reg3 = function(Y,X=list(matrix()),Z=list(matrix()),V=list(matrix()),c=TRUE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...)
   print("XY REGRESSION")
   print("===========================")
   if (is.na(V[[1]][1,1])){
    V=list(V_D(dim(Y)[2])) # can I upgrade this with that thing of Thibault? numeric(n) better than numeric()?
    # this the 'standard' contrast matrix for Y
    for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
      V=c(V,list(V_D(dim(X[i][[1]])[2]))) 
    }
  }
  # here I transform the Y and X to the space of coordinates
  ty = ilr(Y, V[[1]])
  dimD=dim(Y)[2]
  tx = matrix(numeric(dim(X[[1]])[1]*(dimD-1)),dim(X[[1]])[1])+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
  }
  if(c==FALSE){
    tx=tx[,dimD:dim(tx)[2]]
    } # should remove the vector of zeros
  # adding constant Z to the independant variables in the coordinate space
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  Bstar = mlm(ty,tx)
  covb = b_cov(tx,ty,Bstar)
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")
  h=1
  if (c==TRUE){
    b0=inverseilr(Bstar[h:(dimD-1),],V[[1]])
    print("b0 in the simplex:")
    print(b0)
  }
  h=dimD
  if (c==FALSE){
    h=1
  }
  print("---------------------------")
  print("Variance matrix of the parameters:")
  print(covb)
  print("===========================")
  for (i in 1:length(X)){
    print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))
    dimx = dim(X[[i]])[2] #number of parts of this variable i of X D parts --> D-1 param in B*
    matrix_x = Bstar[h:(h+dimx-2),]
    B_q = V[[1]]%*%matrix_x%*%t(V[[i+1]])
    h=h+dimx-1
    print(B_q)
  }
  print("---------------------------")
  for (i in 1:length(Z)){
    print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))
    dimz = dim(Z[[i]])[2]
    matrix_z = Bstar[h:(h+dimz-1),] # it is non comp, it does not lose a dimension in the transformation
    h=h+dimz-1
    c_k = inverseilr(matrix_z, V[[1]])
    print(c_k)
  }
}
```











# Functions on Impacts