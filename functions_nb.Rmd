---
title: "Package Functions (Week 3)"
output:
  html_notebook:
    toc: yes
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    toc: yes
---

# Preliminary Functions (format, maybe warnings and so)

# Operations Functions

## Closure Operator

```{r}
C=function(x, k){ # x the NxD matrix, k the constant (k=1 if missing)
  if (missing(k)){
    newx <- (x)/rowSums(x)
    return(newx)
  }
  else{
    newx <- (k*x)/rowSums(x)
    return(newx)
  }
} 
```


# Transformation functions (ilr, inverseolr,...)

## Function that creates the Helmert Matrix

If $V$ (contrast matrix) is not passed, computations are done with the Helmert Matrix as default.

```{r} 
# Creates de Helmert Matrix given the number of parts of the variable
V_D = function(D){ # D is the dimension (parts)
  V_D = matrix(0L, nrow =D , ncol = D-1)
  for (i in 1:(D-1)){  # pseudodiagonal elements
    V_D[i,i] = (D-i)/(sqrt((D-i+1)*(D-i)))
  }
  for (i in 2:D){ # below pseudodiagonal elements
    for (j in 1:i-1){
      V_D[i,j]=-1/(sqrt((D-j+1)*(D-j)))
    }
  } 
  return(V_D)
}
```

## ILR transformation

Given a matrix NxD and a V contrast matrix, the function returns the ilr-transformed coordinates in a matrix.

```{r}
ilr = function(x, V){ # x matrix N x D
  if (missing(V)){V=V_D(dim(x)[2])}
  x = C(x)
  return(t(t(V)%*%t(log(x))))
}
```


```{r}
m1 = matrix(c(0.25,0.249999,0.2,0.2))
m1 <- cbind(m1, c(0.3, 0.3, 0.3, 0.35))
m1 <- cbind(m1, c(0.45, 0.45, 0.5, 0.45)) # definig the comp matrix
```


## Inverse of the Ilr

```{r}
inverseilr=function(x,V){
  x = t(x)
  if (missing(V)){V=V_D(dim(x)[1]+1)}
  return(C(t(exp(V%*%x))))
}
```



# Functions for the Regression

## Estimation of the coefficients

Given the model: $\begin{pmatrix} y_1\\ y_2\\ ...\\ y_{p}\end{pmatrix} = D\begin{pmatrix}\beta_1\\\beta_2\\...\\ \beta_{p}\end{pmatrix} + \begin{pmatrix}u_1\\u_2\\...\\ u_{p} \end{pmatrix}$

The BLUE estimator of $B$ is obtained computing: 

$\hat{B} = (X^TX)^{-1}X^TY$

```{r}
mlm = function(Y,X){ # only the dependent and independent matrices are needed
  ## use solve(t(X),Y) or QR algorithm qr.solve(), cholesky (I HAVE USED QR)
  B = solve(crossprod(X),crossprod(X,Y),tol=1e-21)
  return(round(B,8))
}
```

## Estimation of the variance


### Function 20. Variance-covariance matrices.

In order to obtain the estimator of the variance matrix of the parameters, first it is needed to estimate the common covariance structure $\Sigma$. Recall that $\mathrm{cov}(Y)=I_n\otimes \Sigma$. Then: 

$\hat{\Sigma}=\dfrac{Y'(I-X(X'X)^{-1}X')Y}{n}=\dfrac{(Y-X\hat{B})'(Y-X\hat{B})}{n}$

```{r}
est_var = function(X,Y,B){ # page 146 kevin
  if (missing(B)){B=mlm(Y,X)}
  n=dim(Y)[1]
  sig = (1/n)*t(Y-X%*%B)%*%(Y-X%*%B)
  return(sig)
}
```

Now we can use the $\mathrm{cov}(\hat{\beta})$ estimator from the Kevin book:

```{r}
# p 145 Kevin (5.13)

b_cov = function(X,Y,B){
  sig = est_var(X,Y,B)
  cov = kronecker(sig,solve(t(X)%*%X))
  return(round(cov,5))
}

```


## Compositional Regressions 

### xy reg (coefficients est.)

Assume we have $k$ explanatory variables (some compositional and some not) and $N$ observations. The dependent variable $Y$ can be compositional or not. In this first version there are four inputs: $Y$, the independent variable which can be compositional (comp=1) or not (comp=0), X is the list of non compositional variables and Z the list of compositional variables. Each variable inside the list is a matrix nxD (D≥1 the number of parts).

Recall that the regression in the ILR coordinate space is defined by:

$\mathrm{ilr}(\mathbf{Y}_i) = \mathbf{b}_0^*+ \sum_{q=1}^Q\mathrm{ilr}(\mathbf{X}_{qi})\mathbf{B}^*_q + \sum_{k=1}^K Z_{ki} \mathbf{b}^*_k + \mathrm{ilr}(\epsilon_i)$


```{r} 
# eq 4 ASJ paper (Ngyugen, Laurent, Thomas-Agnan, Ruiz-Gazen)

# VERSION 1.0.0

xy_reg = function(Y,X=list(matrix()),Z=list(matrix()),V=list(matrix()),c=TRUE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...)x
   print("XY REGRESSION")
   print("===========================")
   if (is.na(V[[1]][1,1])){
    V=list(V_D(dim(Y)[2])) # this the 'standard' contrast matrix for Y
    for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
      V=c(V,list(V_D(dim(X[[i]])[2]))) 
    }
  }
  # here I transform the Y and X to the space of coordinates
  ty = ilr(Y, V[[1]])
  dimD=dim(Y)[2]
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
  }
  if(c==FALSE){
    tx=tx[,-1]
    } # should remove the vector of zeros
  # adding constant Z to the independant variables in the coordinate space
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  #return(list(tx,ty))
  Bstar = mlm(ty,tx)
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")
  if (c==TRUE){
    b0=inverseilr(t(Bstar[1,]),V[[1]])
    print("b0 in the simplex:")
    print(b0)
  }
  h=2
  print("---------------------------")
  for (i in 1:length(X)){
    print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))
    dimx = dim(X[[i]])[2] #number of parts of this variable i of X D parts --> D-1 param in B*
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = V[[1]]%*%t(matrix_x)%*%t(V[[i+1]])
    h=h+dimx-1
    print(t(B_q))
  }
  print("---------------------------")
  for (i in 1:length(Z)){
    print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))
    dimz = dim(Z[[i]])[2]
    if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
    if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
    h=h+dimz-1
    c_k = inverseilr(matrix_z, V[[1]])
    print(c_k)
  }
}
```



WHEN I ADD m3 to Z I always get a singular matrix in X'X how is this possible?

```{r}
m1 = rbind(c(0.25,0.3,0.2),c(0.5,0.2,0.3),c(0.9,0.05,0.05),c(0.33,0.4,0.24),c(0.2,0.3,0.5),c(0.91,0.05,0.04),c(0.1,0.7,0.2)) 
m2 = rbind(c(0.1,0.4,0.25,0.25),c(0.3,0.3,0.3,0.1),c(0.9,0.05,0.02,0.03),c(0.1,0.7,0.15,0.05),c(0.8,0.1,0.05,0.05),c(0.35,0.25,0.3,0.1),c(0.4,0.1,0.1,0.4)) 
m3 = matrix(c(23,1,32,12,9,11,3)) 
m4 = rbind(c(0.2,0.8),c(0.3,0.7),c(0.9,0.1),c(0.75,0.25),c(0.3,0.7),c(0.15,0.85),c(0.9,0.1))
m5 = rbind(c(3,-4.3),c(0,-2),c(4,5),c(-2,3), c(4,2), c(1,11), c(23,2))
```

```{r}
ilr(m2)
```

```{r}
cor(cbind(ilr(m2),ilr(m4),m3,m5))
```


```{r}
ilr(m4)
```


```{r}
xy_reg(Y = m1, X = list(m2,m4), Z=list(m5), c=TRUE)
```

AND

```{r}
xy_reg(Y = m1, X = list(m2), Z=list(m5,m3), c=TRUE)
```

BUT 

```{r}
m2
```

```{r}
m4
```

```{r}
m4
```


```{r}
xy_reg(Y = m1, X = list(m2,m4), Z=list(m5,m3), c=TRUE)
```


```{r}
tx
```

```{r}
t(tx)%*%tx
```

```{r}
det(t(tx)%*%tx)
```


THIS HAPPENS WITH "ANY" m4 matrix.


xy_reg works quite well. To do:

- be sure that it works with different lenghts of the lists of inputs (specially when there is no Z and things like that). We can assume that at least Y and X should be passed (as it is a xy compositional reg).

- add covariance and those things of the mvn package. (copy its report, but no testing). 


### x reg and y reg

**To be done**. If the xy-reg is perfectly done, it would be easier to particularize to x_reg, y_reg. Moreover, may we have only one function for the regression? Something like: 

```
reg(Y=..., X=..., Z=,..., Ycomp=TRUE/FALSE, c=TRUE/FALSE) # where Ycomp indicates whether Y should be understood or not as a compositional variable.
```

### Adding variance of the parameters (xyreg2)


```{r} 

# version 1.0.0 using version 1.0.0 of xy_reg

xy_reg2 = function(Y,X=list(matrix()),Z=list(matrix()),V=list(matrix()),c=TRUE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...)
   print("XY REGRESSION")
   print("===========================")
   if (is.na(V[[1]][1,1])){
    V=list(V_D(dim(Y)[2])) # this the 'standard' contrast matrix for Y
    for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
      V=c(V,list(V_D(dim(X[i][[1]])[2]))) 
    }
  }
  # here I transform the Y and X to the space of coordinates
  ty = ilr(Y, V[[1]])
  dimD=dim(Y)[2]
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
  }
  if(c==FALSE){
    tx=tx[,-1]
    } # should remove the vector of zeros
  # adding constant Z to the independant variables in the coordinate space
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  #return(list(tx,ty))
  Bstar = mlm(ty,tx)
  print("B* in the coordinates space:")
  print(Bstar)
  print("---------------------------")
  print("Matrix of Var/Covar of B*")
  print(b_cov(tx,ty,Bstar))
  
  print("============================")
  if (c==TRUE){
    b0=inverseilr(t(Bstar[1,]),V[[1]])
    print("b0 in the simplex:")
    print(b0)
  }
  h=2
  print("---------------------------")
  for (i in 1:length(X)){
    print(paste("B (in the simplex) for the comp. variable, X", i, sep=""))
    dimx = dim(X[[i]])[2] #number of parts of this variable i of X D parts --> D-1 param in B*
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = V[[1]]%*%t(matrix_x)%*%t(V[[i+1]])
    h=h+dimx-1
    print(t(B_q))
  }
  print("---------------------------")
  for (i in 1:length(Z)){
    print(paste("B (in the simplex) for the non-comp. variable, Z", i, sep=""))
    dimz = dim(Z[[i]])[2]
    if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
    if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
    h=h+dimz-1
    c_k = inverseilr(matrix_z, V[[1]])
    print(c_k)
  }
}
```


```{r}
xy_reg2(Y = m1, X = list(m2), Z = list(m5), c=TRUE)
```



I guess this is more or less all the info we would like to present, but with a different format.


## Copying the (format of) mvn package. It is not 'mvn', is it?

Two ways of output: ilr (default) or simplex spaces. I'll construct -by the moment- the former (xy_reg3). This is the format I would like to replicate: 

![Figure 1: Format of the output](https://raw.githubusercontent.com/i-rb/coda/main/img/eg.png)
It is very important to recall that:

$cov(\beta_{aj},\beta_{bk})=\Sigma_{jk}(X'TX)^{-1}_{ab}$ where $a,b\in{1,..,P}$ variables of $X$ and $j,k\in\{1,...,D}$ parts of Y. (This is from Multivariate Linear Models.
Stanley Sawyer — Washington University. 'multivar_covs' in my PC). 

```{r} 
# VERSION 1.0.0
# using version 1.0.0 of xy_reg2 1.0.0 

xy_reg3 = function(Y,X=list(matrix()),Z=list(matrix()),V=list(matrix()),c=TRUE){ # Y dependent, X indep compositional, Z indep. not compositional, c if constant is included, V list of contrast matrices. order: (Y, X1, X2, ...)
   if (is.na(V[[1]][1,1])){
    V=list(V_D(dim(Y)[2])) # this the 'standard' contrast matrix for Y
    for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
      V=c(V,list(V_D(dim(X[i][[1]])[2]))) 
    }
   }
  # here I transform the Y and X to the space of coordinates
  ty = ilr(Y, V[[1]])
  dimD=dim(Y)[2]
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
  }
  if(c==FALSE){
    tx=tx[,-1]
    } # should remove the vector of zeros
  # adding constant Z to the independant variables in the coordinate space
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  #return(list(tx,ty))
  Bstar = mlm(ty,tx)
  bcov = b_cov(tx,ty,Bstar)
  #print(bcov)
  if (c==TRUE){
    b0=inverseilr(t(Bstar[1,]),V[[1]])
  }
  h=2
  for (i in 1:length(X)){
    dimx = dim(X[[i]])[2] #number of parts of this variable i of X D parts --> D-1 param in B*
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = V[[1]]%*%t(matrix_x)%*%t(V[[i+1]])
    h=h+dimx-1
    B_q = t(B_q)
  }
  for (i in 1:length(Z)){
    dimz = dim(Z[[i]])[2]
    if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
    if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
    h=h+dimz-1
    c_k = inverseilr(matrix_z, V[[1]])
  }
  dimilrY = dim(Y)[2]-1
  mo = dimilrY
  dimvar = dim(bcov)[2]/mo
  names = list("y_ilr1")
  dfres = data.frame(Bstar[,1])
  if (dimilrY>1){
    for (i in 2:dimilrY){
      dfres = cbind(dfres,Bstar[,i])
      name = paste("y_ilr", i, sep="")
      names[[i]]=name
      }
  }
  colnames(dfres) = names
  for (j in mo:1){
    sd = numeric(dim(bcov)[2]/mo)
    for (i in (dim(bcov)[2]/mo):1){
      sd[i]=sqrt(bcov[(i-1)*mo+j,(i-1)*mo+j])
    }
    if (j==mo){
      dfres = cbind(dfres,sd)
    }
    if (j!=mo){
      dfres = cbind(dfres[1:j],sd,dfres[(j+1):(dim(dfres)[2])])
    }
  }
  
  
  # renaming
  rname = c("(intercept)")
  for (i in 1:length(X)){
    for (j in 1:((dim(X[[i]])[2])-1)){
    newname = paste("Xilr_",i,"_",j,sep="")
    rname = c(rname, newname)
    }
  }
  if (!is.na(Z[[1]][1,1])){
    for (i in 1:length(Z)){
      for (j in 1:(dim(Z[[i]])[2])){
      newname = paste("Z_",i,"_",j,sep="")
      rname = c(rname, newname)
      }
    }
  }
  rownames(dfres)=rname
  return(dfres)
}
```


The original output is a DataFrame (I don't like it):


```{r}
xy_reg3(m1,list(m2),list(m5))
```


I prefer the plain text matrix:

```{r}
a=xy_reg3(m1,list(m2),list(m5)) # simplex_result=TRUE (no sd for the simplex)
round(as.matrix(a),5)
```


So here I create a new function (only to make a prettier report), xy_reg4:
(I should copy the 'mnv' summary as Christine said)

```{r}
xy_reg4 = function(Y, X, Z){
  print("                     Results of the YX-Regression                     ")
  print("======================================================================")
  a=Sys.time()
  print(paste("                                                   ", a, sep=""))
  result = xy_reg3(Y, X, Z)
  print("                                                                      ")
  print(round(as.matrix(result),5))
  n = dim(Y)[1]
  print("______________________________________________________________________")

  summary = data.frame(c(n,133.2,TRUE,991))
  rownames(summary)= c("N obs", "F-statistic", "Comp?", "R2")
  colnames(summary)= c("Summary")
  print(as.matrix(summary))
}
```

```{r}
xy_reg4(m1,list(m2),list(m5))
```



# Functions on Impacts

First, I will try to compute the YX-compositional model elasticities (without total), which can be computed as (Morais, Thomas-Agnan, 2021):

$\dfrac{\partial \log \mathbb{E}^\oplus Y}{\partial\log\check{X}}=W_{\mathbb{E}^\oplus Y}B$

with $W_z = I_D - 1_Dz'$ and $z$ a compositional variable.

I have translated the code from Shuyao Li to this enviroment, but the approaches differ.

First, I need to modify our function to return B (instead of B*) to use it here directly:

```{r}
# modification of reg_xy() v.1.0.0
# version 1.0.0

B_reg = function(Y,X=list(matrix()),Z=list(matrix()),V=list(matrix()),c=TRUE){ 
   if (is.na(V[[1]][1,1])){
    V=list(V_D(dim(Y)[2])) # this the 'standard' contrast matrix for Y
    for (i in 1:length(X)){ # here 'standard' contrast matrices for X are added
      V=c(V,list(V_D(dim(X[i][[1]])[2]))) 
    }
  }
  # here I transform the Y and X to the space of coordinates
  ty = ilr(Y, V[[1]])
  dimD=dim(Y)[2]
  tx = matrix(numeric(dim(X[[1]])[1]))+1 # here it is created a matrix which is a vector of ones (should be removed afterwords if c=False)
  for (i in 1:length(X)){
    tx = cbind(tx,ilr(X[[i]],V[[i+1]])) # the transformed X is created as a unique matrix
  }
  if(c==FALSE){
    tx=tx[,-1]
    } # should remove the vector of zeros
  # adding constant Z to the independant variables in the coordinate space
  if (!is.na(Z[[1]][1,1])){
    for (z in Z){
      tx=cbind(tx,z)
    }
  }
  #return(list(tx,ty))
  Bstar = mlm(ty,tx)
  
  res_mat = t(matrix(numeric(dim(Y)[2])))
  
  if (c==TRUE){
    b0=inverseilr(t(Bstar[1,]),V[[1]])
    res_mat = rbind(res_mat,b0)
  }
  h=2
  for (i in 1:length(X)){
    dimx = dim(X[[i]])[2] #number of parts of this variable i of X D parts --> D-1 param in B*
    if (h==(h+dimx-2)){matrix_x = t(matrix(Bstar[h,]))}
    if (h!=(h+dimx-2)){matrix_x = Bstar[h:(h+dimx-2),] }
    B_q = V[[1]]%*%t(matrix_x)%*%t(V[[i+1]])
    h=h+dimx-1
    res_mat = rbind(res_mat, t(B_q))
  }
  for (i in 1:length(Z)){
    dimz = dim(Z[[i]])[2]
    if (h==(h+dimz-1)){matrix_z = t(matrix(Bstar[h,]))}
    if (h!=(h+dimz-1)){matrix_z = Bstar[h:(h+dimz-1),]} # it is non comp, it does not lose a dimension in the transformation
    h=h+dimz-1
    c_k = inverseilr(matrix_z, V[[1]])
    res_mat = rbind(res_mat, c_k)
  }
  return(res_mat[-1,])
}
```


```{r}
xy_elas = function(Y, B, i){ # Y matrix in the simplex, i index of the X comp variable, B is given in the simplex form we got previously
  TT= nrow(Y) # number of observations
  D = ncol(Y)
  e = matrix(rep(1,D*TT), ncol=D, nrow=TT)
  Bi = B[i,]
  for (t in (1:TT)){
    W = matrix(rep(Y[t, ], times  = D), nrow = D, ncol = D, byrow = TRUE)
    W =  diag(D) - W
    e[t,] <- t(W%*%Bi)
  }
  return(e)
}
```

I test it...

```{r}
testB = B_reg(m1,list(m2),list(m5))
xy_elas(m1,testB,2)
```


Below is the well constructed functions (one from B and one from data), but which is the output we want? Here -in general- makes no sense to plot the time series plot that I usually see. Maybe an scatter plot linking impact and state (value of x)? an histogram?...




```{r}
xy_imp_data = function(Y,X=list(matrix()),Z=list(matrix()),V=list(matrix()),c=TRUE, ts=FALSE, h=FALSE, show=TRUE, name="output_impacts.pdf"){
  B = B_reg(Y, X, Z, V, c)
  if (show==TRUE){
    print("              XY IMPACTS                 ")
    print("=========================================")
    print("B in the simplex: ")
    print(B)
    print("=========================================")
  }
  if ((ts+h)>0){
    pdf(name)
    plot.new()
    txt=("Graphics of XY Impacts")
    text(.5, .5, txt, font=2, cex=1.5)
    txt=("Includes:")
    text(.1, .3, txt, font=2, cex=1)
    ypos=.2
    if (ts==1){
      txt="Time Series Plot"
      text(.2, ypos, txt, font=2, cex=1)
      ypos=ypos-0.1
    }
    if (h==1){
      txt="Histograms"
      text(.2, ypos, txt, font=2, cex=1)
      ypos=ypos-0.1
    }
  }
  
  init = c
  for (i in 1:length(X)){
    for (k in 1:(dim(X[[i]])[2])){
      elas = xy_elas(Y,B,c+1)
      if (show==TRUE){
        print(paste("Impact of the variable X_",i,"_",k, sep=""))
        print(elas)
        print("                                         ")
      }
      
      if (ts == TRUE){
        dim_y = dim(Y)[2]
        ramp = colorRamp(c("Red","Green","Blue","Pink"))
        colors = rgb(ramp(seq(0,1,length=dim_y)),max=255)
        plot(elas[,1],type="l",col=colors[1],ylim=c(min(elas),max(elas)),main=paste("TS plot of elasticities of ","X_",i,"_",k,sep=""))
        legleg = c(paste("X_",i,"_",k,"_1",sep=""))
        legcol = c(colors[1])
        if (dim_y!=1){
          for (n in (2:dim_y)){
          lines(elas[,n],col=colors[n])
          legleg = c(legleg, paste("X_",i,"_",k,"_",n,sep=""))
          legcol = c(legcol, colors[n])
          }
        }
        legend("topright",legend=legleg,col=legcol,lty=1, cex=0.8)
        
      }
      
      if (h==TRUE){
        dim_y = dim(Y)[2]
        hist(elas[,1], xlab = "Elasticity", main=paste("Histogram of elasticities of ","X_",i,"_",k,"_",1,sep=""))

         if (dim_y!=1){
           for (n in (2:dim_y)){
             hist(elas[,n], xlab = "Elasticity", main=paste("Histogram of elasticities of ","X_",i,"_",k,"_",n,sep=""))
           }
         }
      }
      c=c+1
      }
  }
  if (show==TRUE){print("-----------------------------------------")}
  for (j in length(Z)){
    for (k in 1:(dim(Z[[j]])[2])){
      elas = xy_elas(Y,B,c+1)
      if (show==TRUE){print(paste("Impact of the variable Z_",j,"_",k, sep=""))
          print(elas)
          print("                                         ")}
      
      
      if (ts == TRUE){
        dim_y = dim(Y)[2]
        ramp = colorRamp(c("Red","Green","Blue","Pink"))
        colors = rgb(ramp(seq(0,1,length=dim_y)),max=255)
        plot(elas[,1],type="l",col=colors[1],ylim=c(min(elas),max(elas)),main=paste("TS plot of elasticities of ","Z_",j,"_",k,sep=""))
        legleg = c(paste("Z_",j,"_",k,"_1",sep=""))
        legcol = c(colors[1])
        if (dim_y!=1){
          for (n in (2:dim_y)){
          lines(elas[,n],col=colors[n])
          legleg = c(legleg, paste("Z_",j,"_",k,"_",n,sep=""))
          legcol = c(legcol, colors[n])
          }
        }
        legend("topright",legend=legleg,col=legcol,lty=1, cex=0.8)
      }
      
  
      
      
      if (h==TRUE){
        dim_y = dim(Y)[2]
        hist(elas[,1], xlab = "Elasticity", main=paste("Histogram of elasticities of ","Z_",j,"_",k,"_",1,sep=""))
        if (dim_y!=1){
          for (n in (2:dim_y)){
            hist(elas[,n], xlab = "Elasticity", main=paste("Histogram of elasticities of ","Z_",i,"_",k,"_",n,sep=""))
           }
         }
      }
      c=c+1
    }
  }
  if ((ts+h)>0){
    dev.off()
  }
}
```


```{r}
# how to define attributes
a <- matrix(0,3,3)
attr(a, "type") <- "simplex"
attr(a, "V") <- m1
a
```

```{r}
attr(a, "type") == "simplex"
```



```{r}
xy_imp_data(m1,list(m2),list(m5),h=TRUE,ts=TRUE)
```




```{} 
# Shuyao code (it does not work as such)

fun.elast_YXcompo <- function(S,B_star,i,D=ncol(S)){   
  S <- as.matrix(S)
  T <- nrow(S)
  B_intermediate <- compositions::ilrInv(B_star)
  B <- as.matrix(compositions::ilrInv(t(B_intermediate),orig = compX))
  B<- B[,i]
  e <- matrix(rep(1,D*T), ncol=D, nrow=T)
  colnames(e) <- colnames(S)
  for (t in 1:T){
    W = matrix(rep(S[t, ], times  = D), nrow = D, ncol = D, byrow = TRUE)
    W =  diag(D) - W
    e[t,] <- t(W %*% B)
  } 
  return(e)
}
```
